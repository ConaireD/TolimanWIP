{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"TOLIMAN","text":"<p>The goal of the TOLIMAN mission is to answer the question: is there a planet around Alpha Centauri? The critical advance represented by the TOLIMAN  telescope is its ability to assess a specific star. The TOLIMAN mission aims to detect the  gravitational reflex motion of the host star induced by an Earth mass companion. For nearby stars  the expected signal strength is expected to be sub-\u00b5as - well below the diffraction limit of most telescopes. To achieve this TOLIMAN will be launched into space with new technologies that will attempt to beat this limit. This page contains the forwards model that will be used to extract any signals.</p>"},{"location":"CONTRIBUTING/","title":"CONTRIBUTING","text":""},{"location":"CONTRIBUTING/#contributing","title":"Contributing","text":"<p>There is plenty that still needs to be done to make the forwards model flight  ready. If you wish to add layers to the optical system of the detector then  you can do this within the <code>__init__</code> methods of the respective classes.  Once you have finished with your changes please run <code>black</code> and <code>pydocstyle</code>. Unfortunately you will have to manually make the changes with <code>pydocstyle</code>.  These should come with the full installation of <code>toliman</code>.</p> <p>Two additional features that I am aware of, which need to be added are support  for Fresnel and a raytraced secondary mirror polish. The Fresnel will require that an old code for <code>dLux</code> be updated to match the latest release. In addition, once a physical detector is selected it will need to be tested and its  parameters and noise sources incorporated into this model. </p> <p>The tests were created so that after making changes you can simply run the tests to confirm that the existsing features still work. That said sometimes you will  need to change and even delete tests depending on the magnitude of the changes. If you do so please validate the new tests. To run the tests simply invoke  <code>pytest</code> from within the root of the <code>git</code> repository. It will automatically  detect and run all of the tests, which may take some time. </p> <p>Other than that, we are using type annotations, but in a relaxed sense, relying  only on the inbuilt <code>python</code> types and avoiding using <code>typing</code> as much as  possible since it reduces the complexity of the code. It was tempting to  use <code>jaxtyping</code>, but this can lead to very long and very confusing function  signatures for the unwary. It may be something that is pursued in later  releases. Other aspects of the style should be self apparent from the  existing code base. </p>"},{"location":"INSTALLATION/","title":"INSTALLATION","text":""},{"location":"INSTALLATION/#installation","title":"Installation","text":"<p>This is a minimal installation guide that does not tell you how to use any  of the powerful tools you will install. If you want more information search  for yet another astronomy blog (YAAB), a blog that was actuall spun out of the handover for this project. If you just wish to use the forwards model and  are not interested in developing it further you can just run <code>pip install toliman</code>. However, installing a development copy is a little more difficult.  Firstly, you will need to install <code>git</code> and <code>poetry</code>. Using a package  manager (like <code>brew</code>) it is as simple as <code>brew install git</code> and <code>brew install  poetry</code>. </p> <p>Tip</p> <p>If you want to validate that these are indeed the correct pacakges  before installing them onto your computer most package managers support a  <code>search</code> function. For example <code>brew search poetry</code>. If you want to  validate the packages are correctly installed then run <code>git --version</code>  and <code>poetry --version</code>. </p> <p>Next run <code>git clone https://ConaireD/TolimanWIP.git</code> which will clone  the repository into <code>TolimanWIP</code>. You can change the name using the <code>-O</code> flag. Move into cloned repository and run <code>poetry install</code>. This will  take a moment but once it is finished you will have a safe debug build. </p> <p>Unfortunately this is not the end of the road. Open a <code>python</code> terminal  using <code>python</code> and add the following two lines, <pre><code>import toliman\ntoliman.build.install_toliman(number_of_wavelengths = ..., force = True)\n</code></pre> This should fetch a large number of data files from the internet and then  you are good to go. The <code>number_of_wavelengths</code> parameter indicates how  many wavelengths to use for the spectrum of Alpha Centauri.</p> <p>Tip</p> <p>By default <code>toliman</code> will create a <code>.assets</code> folder to store the  datafiles in. If you want it to be something else you must export  the constant <code>TOLIMAN_HOME</code> before running <code>install_toliman</code>.  I would recommend adding the definition to you <code>.zprofile</code>/<code>.bashrc</code>  so that you do not need to export it everytime you want to use  <code>toliman</code>.</p> <p>Note</p> <p>You may be wondering why we did not make the installation run via a  command line interface. The reason is that it would need to be  invoked via <code>python install.py</code>. While this looks very clean it does  not give the user very much flexibilty if they wish to update individual  datafiles later. The <code>toliman.build</code> submodule handles this and the  API is heavily documented. </p>"},{"location":"LICENSE/","title":"LICENSE","text":"<p>Copyright 2023 ConaireD, Jordan Dennis and Peter Tuthill</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files, to deal in the Software without restriction, including without limitation to the rights of use, copy, modify, merge, publish, distribute, and sub-license copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to  the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in  all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGMENT. IN NO EVENT SHALL THE  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE  SOFTWARE.</p>"},{"location":"examples/gradient_descent/","title":"Gradient descent","text":""},{"location":"examples/gradient_descent/#gradient-descent","title":"Gradient Descent","text":"<p>The current plan for the extraction pipeline is to use gradient descent to  find the starting state for Hamiltonian Monte Carlo (HMC). In this notebook, we cover a simple, low parameter optimisation using <code>optax</code>.</p> <pre><code>import jax\nimport jax.numpy as np\nimport jax.lax as jl\nimport jax.random as jr\nimport toliman\nimport toliman.constants as const\nimport toliman.math as math\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport tqdm.notebook as tqdm\nimport dLux\nimport optax\nimport equinox\nimport os\n</code></pre> <p>Next, we organise the housekeeping; i.e. collecting true values, setting  the working directory and chosing graphics. The working directory needs  to be set in the directory that contains <code>.assets</code> or where-ever you told toliman to install the datafiles.</p> <pre><code>mpl.rcParams[\"text.usetex\"] = True\nmpl.rcParams[\"font.family\"] = \"serif\"\nmpl.rcParams[\"font.serif\"] = \"Times New Roman\"\nmpl.rcParams[\"font.size\"] = 20.0\nmpl.rcParams[\"image.cmap\"] = \"inferno\"\n\ntrue_separation: float = const.get_const_as_type(\"ALPHA_CENTAURI_SEPARATION\", float)\ntrue_position: float = const.get_const_as_type(\"ALPHA_CENTAURI_POSITION\", np.ndarray)\ntrue_pixel_scale: float = const.get_const_as_type(\"TOLIMAN_DETECTOR_PIXEL_SIZE\", float)\ntrue_flux: float = const.get_const_as_type(\"ALPHA_CENTAURI_MEAN_FLUX\", float)\ntrue_contrast: float = const.get_const_as_type(\"ALPHA_CENTAURI_CONTRAST\", float)\n\nos.chdir(\"..\") # Specific for our installation.\n</code></pre> <p>Now we can create our model. Since, this is an example, we are keeping things simple and just simulating the physical telescope and the mask without  adding zernike polyomials. Since, we are not trying to learn the positions etc., of the pupil we will set it to static using the <code>operate_in_static_mode</code> flag. This is much faster than using a dynamic pupil.</p> <pre><code>model: object = dLux.Instrument(\n    optics = toliman.TolimanOptics(operate_in_static_mode = True),\n    detector = toliman.TolimanDetector(),\n    sources = [toliman.AlphaCentauri(), toliman.Background(number_of_bg_stars = 5)]\n)\n</code></pre> <p>Note</p> <p>Be careful with the background stars. Although we tried to get a \"typical\" sample using the Gaia database, we had trouble working out the relative  brightness. Gaia does not cope that well with bright stars so it very much  underestimated the brightness of Alpha Centarui. We had a rather commical  hole in the field of stars where Alpha Centarui was but a low brightness  for the actual star. We have used this value so make sure that you  manually check the PSF and adjust the brighness of the background stars  if you think it is necessary. This can be done using:</p> <pre><code>model.set(\"MultiPointSource.flux\", model.get(\"MutliPointSource.flux\") * ...)\n</code></pre> <p>Now let's simulate some data and plot the results. </p> <pre><code>psf: float = model.model()\ndata: float = math.simulate_data(psf, 1)\n\ndef im_and_cbar(figure: object, image: float, pos: int, title: str, naxes: int) -&gt; object:\n    cbar_pad: float = 0.05\n    cbar_width: float = 0.0125\n    width: float = 1.0 / naxes - cbar_pad\n    disp: float = cbar_pad / 2.0 * naxes\n    height: float = 1.0 - 2.0 * disp\n    corner: float = float(pos) / float(naxes)\n    im_ax: object = figure.add_axes([corner, disp, width, height])\n    cbar_ax: object = figure.add_axes([corner + width, disp, cbar_width, height])\n    im_cmap: object = im_ax.imshow(image)\n    im_cbar: object = figure.colorbar(im_cmap, cax = cbar_ax)\n    im_xticks: object = im_ax.axis(\"off\")\n    im_title: object = im_ax.set_title(title) \n    return figure\n\nscale: float = 5.0\nnaxes: int = 3\nfigure: object = plt.figure(figsize = (naxes * scale, scale))\nfigure: object = im_and_cbar(figure, psf, 1, \"PSF\", 3)\nfigure: object = im_and_cbar(figure, data, 2, \"Data\", 3)\nfigure: object = im_and_cbar(figure, data - psf, 3, \"Residuals\", 3)\n</code></pre> <p></p> <p>We are interested in the parameters of the Alpha Centauri object ignoring  the field angle. However, we do not want to use the model we used to generate the data to perform the gradient descent. Instead we want to perturb the  relevant parameters a little. I generated my perturbations by considering  how well the results could be eyeballed. I thought I could probably get the  position to within a pixel each way and then for the sake of completeness  assumed a gaussian error. Separation, contrast and flux followed similar  reasoning.</p> <p>Note</p> <p>We are ignoring the field angle to match the HMC example.</p> <p>Tip</p> <p>The <code>params</code> variable is a set of paths that <code>Zodiax</code> can use to  access/update the parameters of the model. The perturbations  are the changes that we want to apply in the same order. It is  easy to loose track of which element of the list references which parameter and my solution to this problem is to define constants that I can use for indexing. For example,</p> <pre><code>data: list = [\"fish\", \"mamal\", \"bird\"]\nFISH: int = 0\nMAMAL: int = 1\nBIRD: int = 2\n\ndata[FISH] = \"fish\"\ndata[MAMAL] = \"mamal\"\n</code></pre> <p>This only works while the list is not changed. If someone were to  mutate the list then your indexing would break.</p> <pre><code>params: list = [\n    \"BinarySource.position\",\n    \"BinarySource.separation\",\n    \"BinarySource.flux\",\n    \"BinarySource.contrast\"\n]\n\nperturbations: list = [\n    true_pixel_scale * jr.normal(jr.PRNGKey(0), (2,)),\n    5 * true_pixel_scale * jr.normal(jr.PRNGKey(0), ()),\n    0.1 * true_flux * jr.normal(jr.PRNGKey(1), ()),\n    0.1 * true_contrast * jr.normal(jr.PRNGKey(2), ()),\n]\n\noptimizers: list = [\n    optax.adam(learning_rate = 0.005 * true_pixel_scale),\n    optax.adam(learning_rate = 0.005 * true_pixel_scale),\n    optax.adam(learning_rate = 0.0005 * true_flux),\n    optax.adam(learning_rate = 0.0001 * true_contrast),\n]\n\nPOSITION: tuple = (0, 1)\nSEPARATION: int = 2\nFLUX: int = 3\nCONTRAST: int = 4\n</code></pre> <p>You may notice that my constants don't quite make sense and that is  because <code>position</code> counts as an <code>x</code> and a <code>y</code> parameter. We will see  this is useful later in indexing arrays. </p> <p>Tip</p> <p><code>jax</code> arrays can be indexed by tuples. </p> Example <pre><code>&gt;&gt;&gt; import jax.numpy as np\n&gt;&gt;&gt; arr: float = np.zeros((5, 5), dtype = float)\n&gt;&gt;&gt; arr[:, (0, 1)].shape\n::: (5, 2)\n</code></pre> <p>Now let's define the loss function. In this case I am doing a simple  chi-squared loss. I would recommend using a different syntax for the  code, I just got carried away telling the computer what to do instead  of focussing on the science. The important things to take note of are <code>model.get_args</code> and <code>equinox.filter_value_and_grad</code> and <code>equinox.filter_jit</code>.</p> <p>Tip</p> <p><code>equinox.filter_jit</code> will mark all the parts of the model that <code>jax</code>  would break on as static preventing compilation errors.  `equinox.</p> <pre><code>@equinox.filter_jit\n@equinox.filter_value_and_grad(arg = model.get_args(paths = params))\ndef eval_loss(model: object, data: float) -&gt; float:\n    psf: float = model.model()\n    res: float = psf - data\n    sq_err: float = jl.integer_pow(res, 2)\n    loss: float = jl.reduce(sq_err, 0.0, jl.add, (0, 1))\n    return loss\n</code></pre> <p>Finally, we can set up the gradient descent loop. First we add our perturbations to the model using the <code>zodiax</code> <code>add</code> syntax. Then we use the <code>zodiax</code> <code>get_optimiser</code> syntax to generate the appropriate <code>optax.optim</code> object. Since I am interested in the first and last state of the model I make an  implicit copy of the initial state that I will use in the learning model. Finally, we set up the residuals from the known global minimum as an array.</p> <pre><code>perturbed_model: object = model.add(params, perturbations)\noptimizer, opt_state = perturbed_model.get_optimiser(params, optimizers)\nlearning_model: object = perturbed_model # Implicit copy\nfull_residuals: float = np.hstack(learning_model.get(params)) - np.hstack(model.get(params))\n</code></pre> <p>Now we run the learning loop for <code>500</code> iterations and collect the residuals  at each epoch. We are interested in the residuals so that we can analyse our choice of learning rate. The updates are applied using the  <code>equinox.apply_updates</code> function. </p> <pre><code>with tqdm.tqdm(range(500)) as t:\n    for i in t:\n        # calculate the loss and gradient\n        loss, grads = eval_loss(learning_model, data)\n\n        # apply the update\n        updates, opt_state = optimizer.update(grads, opt_state)\n        learning_model: object = equinox.apply_updates(learning_model, updates)\n\n        residuals: float = np.hstack(learning_model.get(params)) - np.hstack(model.get(params))\n        full_residuals: float = np.vstack([full_residuals, residuals])\n\n        t.set_description('Loss %.5f' % (loss)) # update the progress bar\n</code></pre> <p>Finally, let's check our learning rates by plotting the residuals. </p> <p>Tip</p> <p>Your learning rate should be a small percentage of the perturbation' from the true value. Obviously in practice you don't know what the  the perturbation is, but one can assume that it is a small percentage  of the true value. If the residuals \"bounce\" around then the learning  rate is likely too high. </p> <pre><code>epochs: float = np.arange(full_residuals.shape[0])\nfigure: object = plt.figure(figsize=(8, 8), constrained_layout=True)\naxes: object = figure.subplots(2, 2)\naxes[0][0].plot(epochs, full_residuals[:, POSITION])\naxes[0][0].set_title(\"Position (radians)\")\naxes[0][1].plot(epochs, full_residuals[:, SEPARATION])\naxes[0][1].set_title(\"Separation (radians)\")\naxes[1][0].plot(epochs, full_residuals[:, FLUX])\naxes[1][0].set_title(\"Flux (photons)\")\naxes[1][1].plot(epochs, full_residuals[:, CONTRAST])\naxes[1][1].set_title(\"Contrast (none)\")\n</code></pre> <p></p>"},{"location":"examples/hmc/","title":"Hmc","text":""},{"location":"examples/hmc/#hamiltonian-markov-chain-monte-carlo-hmc","title":"Hamiltonian Markov-Chain-Monte-Carlo (HMC)","text":"<p>In this example, we use the <code>toliman</code> forwards model to learn the posterior  distributions of some of the parameters of the Alpha Centauri pair. The example, neglects aberrations and other such sources of error since it was not  feesible to run more complex simulations on a standard laptop. </p> <p>The first thing that you might notice is that we use a lot of packages.  Firstly, its not as bad as it looks as we import submodules from each  package under their own names. This is an insignificant detail and we  really don't care how you chose to do your imports.</p> <pre><code>import toliman\nimport toliman.math as math\nimport toliman.constants as const\nimport jax\nimport jax.numpy as np\nimport jax.random as jr\nimport jax.lax as jl\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport numpyro as npy\nimport numpyro.distributions as dist\nimport dLux \nimport equinox\nimport os\nimport chainconsumer as cc\n</code></pre> <p>Let's adjust some of the global <code>matplotlib</code> parameters. We want to use LaTeX to render our axis ticks and titles so we will set <code>text.usetex</code> to  <code>True</code>. We also want large titles so we will increase <code>axes.titlesize</code>. There is a huge list of parameters that can be set customising most of the  aspects of a plot. These are just the ones we have chosen.</p> <pre><code>mpl.rcParams[\"text.usetex\"] = True\nmpl.rcParams[\"axes.titlesize\"] = 20\nmpl.rcParams[\"image.cmap\"] = \"inferno\"\n</code></pre> <p>The next line simply makes sure that the code is running in <code>TOLIMAN_HOME</code>. This is something that you will need to do to make sure that toliman can  find the necessary data files. It shouldn't be too painful. </p> <p><code>os.chdir</code> stands for <code>change_dir</code>, but for legacy reasons a lot of the  standard library doesn't use modern naming conventions. This is the function  that changes the working directory. I have programatically generated  <code>TOLIMAN_HOME</code> from the current directory (<code>os.getcwd</code>), but you could  just retrieve the constant. </p> <pre><code>os.chdir(\"\".join(os.getcwd().partition(\"toliman\")[:2]))\n</code></pre> <p>Five lines and we have generated the forwards model. We are using mostly  the default settings so no aberrations. We have set the pupil to be static  since it is unlikely to be a major source of error/noise that we need to  account for and static apertures are much faster. </p> <p>As I described in the overview for <code>toliman/toliman.py</code>, the default  detector is currently a stub since a physical detector has not yet been  selected. We are just using the default noise sources, which are jitter, saturation and pixel responses. </p> <p>We are also accounting for some background stars in our simulation although  they are very faint. The main concern with the background stars is that the  sidelobes will obscure neighbouring central PSFs. Unfortunately, this suspicion  is yet to be confirmed or refuted. The model is linear with the number of  stars so be careful not to simulate too many. In my case five was doable. </p> <p>There is a careful tradeoff to be had between the number of stars, which  are simulated mono-chromatically and the resolution of the Alpha Centauri  spectrum. The model is linear with respect to both parameters, so you will  find that when operating near the memory limit of your machine, if you  increase one, you will need to decrease the other. </p> <pre><code>model: object = dLux.Instrument(\n    optics = toliman.TolimanOptics(operate_in_static_mode = True),\n    detector = toliman.TolimanDetector(),\n    sources = [toliman.AlphaCentauri(), toliman.Background(number_of_bg_stars = 5)]\n)\n</code></pre> <p>Let's generate some pretend data and try and recover the parameters of  Alpha Centauri. The <code>toliman.math</code> module provides a <code>simulate_data</code>  function, which applies poisson noise and gaussian white noise to the  data. The magnitude of the gaussian noise is controlled by the scale  parameter. For realistic values I would recommend representing it as  a fraction of the maximum or the norm as I have done here. </p> <p>You'll notice that we then flatten the data. This is so that it plays  nicely with <code>numpyro</code>. <code>numpyro</code> has by far the worst API I can imagine and it consistently manages to confuse my stupid ass. This is of course  a personal rant, since <code>numpyro</code> is more targetted torwards experts and  statisticians for whom this is bread and butter.</p> <pre><code>psf: float = model.model()\ndata: float = math.simulate_data(psf, 0.001* np.linalg.norm(psf))\nfdata: float = data.flatten()\n</code></pre> <p>Let's examine our glorious PSF, pretend data and the residuals. If you  haven't used <code>matplotlib</code> before then this is a good opportunity to  learn a few tricks. I've recorded an explanation of what is happening  in the admonition (collapsible window).</p> Note <p><code>matplotlib</code> is a very ... complex package. There are about a million  ways to do anything, generally trading simplicity for control. A big  reason for this is that <code>matplotlib</code> tends to expose certain functionality  at multiple levels in the API. For example, <code>plt.subplots</code> vs  <code>figure.subplots</code>. I do not claim to be a <code>matplotlib</code> guru but I  have find interacting with <code>matplotlib</code> as hierachically as possible  tends to produce the best results. </p> <p>First we generate a <code>figure</code> using <code>plt.figure</code>. Since, I want to have  two rows of figures with two in the top row and a single, central figure  in the second row I will create divide the figure into two subfigures  stacked atop one another using <code>figure.subfigures(2, 1)</code>. To get the  images I want to display to have the right size and dimensions I can  add axes to the subfigures. I do this using the <code>figure.add_axes</code> command. </p> <p>I like to create a specific set of axes for the colobar, as otherwise it  can be quite hard to get it to sit correctly with respect to the figure.  I create a tall, narrow set of axes for this purpose and sit it flush  against the axes for the figure. I then direct <code>matplotlib</code> to draw the  colobar on these axes. </p> <pre><code>def plot_image_with_cbar(\n        figure: object,\n        image: float, \n        corner: list, \n        width: float, \n        height: float,\n        title: str,\n    ) -&gt; object:\n    x: float = corner[0]\n    y: float = corner[1]\n    im_axes: object = figure.add_axes([x, y, width, height])\n    cbar_ax: object = figure.add_axes([x + width, y, 0.05, height])\n    im_cmap: object = im_axes.imshow(image)\n    im_cbar: object = figure.colorbar(im_cmap, cax = cbar_ax)\n    im_ticks: list = im_axes.axis(\"off\")\n    im_frame: None = im_axes.set_frame_on(False)\n    im_title: object = im_axes.set_title(title) \n    return figure\n\nsize: float = 5.0\nfigure: object = plt.figure(figsize = (2 * size, 2 * size))\nsubfigures: object = figure.subfigures(2, 1)\n\npsf_fig: object = plot_image_with_cbar(\n    subfigures[0], np.cbrt(psf), [0.0, 0.1], 0.4, 0.8, \"Model\"\n)\npsf_fig: object = plot_image_with_cbar(\n    psf_fig, np.cbrt(data), [0.55, 0.1], 0.4, 0.8, \"Data\"\n)\nres_fig: object = plot_image_with_cbar(\n    subfigures[1], np.cbrt(psf - data), [0.25, 0.1], 0.4, 0.8, \"Residuals\"\n)\n</code></pre> <p></p> <p>Now that we know what the model and data look like let's do some HMC.  You may recall that earlier I made a reference to flattening the data  for <code>numpyro</code>. We did this because <code>numpyro</code> supports a very unusual form of loop syntax, presumably so that it was easier to interact with the  <code>jax</code> vectorisation magic in the <code>google</code> dimension. Simply said, when you  want to make an observation over a set, for example the pixels in an image you must do so within the <code>plate</code> context manager. </p> <p>A wiser individual than I will link the name <code>plate</code> to a PGM, which presumably  stands for something; I wouldn't know. I simply think of it as a vectorised  for loop allowing the data output to be non-scalar. Thus one deals with the  problem of <code>jax.grad</code> requiring scalar outputs. There are of course other  autodiff functions that allow non-scalar outputs, but this is a solution that  works.</p> <p>Note</p> <p>I feal required to tell you that my explanation is largely speculative.  I haven't really analysed the <code>numpyro</code> source code in a large amount  of detail. Like most large codebases, seeing how all the pieces fit  together is very difficult.</p> <p>Let's now examine the sampling in more detail. For each posterior that  we want to learn we <code>sample</code> the corresponding parameter, based on some  prior. In my example I use ignorant priors, which are uniform or uniform  in log space for magnitude parameters. A strange and unfriendly feature  of <code>numpyro</code> is that it likes to sample near 1. It always seems to be best to indulge <code>numpyro</code> and transform a value sampled around 1 into the actual value using the <code>numpyo.deterministic</code> function.</p> <p>Note</p> <p>I have no idea why <code>numpyro</code> is like this. I wish it wasn't. The best  justification that I can give, is that it ensures numerical stability.</p> <p>You will notice that the first argument to the so called <code>numpyro.primitives</code> is a string, in our case just a repeat of the variable name. Once again this  has to do with how <code>numpyro</code> handles the information, associating these names  with the array of samples. It would make more sense (possibly) to use names  that you wish to plot for these parameters, saving you some time later. </p> <p>The penultimate line in the <code>hmc_model</code> function is where the magic happens: Louis's one line <code>model.update_and_model</code> method. This takes the values we  sampled from our prior and injects them into the model, before running it  to generate a PSF. We pass the <code>flatten=True</code> argument so that the shape  of the PSF matches the flattened data. We also have to tell the model what  parameters to update and what values to update them to. This is achieved  through the twin lists: paths and values. This taps into the <code>zodiax</code> interface for pytrees so if you are confused look there.</p> <p>Note</p> <p>We could of course flatten the PSF manually using <code>model.update_and_model(*args).flatten()</code>, but it is a common enough  occurance that it was included as an argument. </p> <p>Note</p> <p>You may notice that before comparing the model to the data we use it to  generate a poisson sample. This is because photon noise is likely to  be the largest noise source. </p> <pre><code>true_pixel_scale: float = const.get_const_as_type(\"TOLIMAN_DETECTOR_PIXEL_SIZE\", float)\ntrue_separation: float = const.get_const_as_type(\"ALPHA_CENTAURI_SEPARATION\", float)\n\ndef hmc_model(model: object) -&gt; None:\n    position_in_pixels: float = npy.sample(\n        \"position_in_pixels\", \n        dist.Uniform(-5, 5), \n        sample_shape = (2,)\n    ) \n    position: float = npy.deterministic(\n        \"position\", \n        position_in_pixels * true_pixel_scale\n    )\n\n    logarithmic_separation: float = npy.sample(\n        \"logarithmic_separation\", \n        dist.Uniform(-5, -4)\n    )\n    separation: float = npy.deterministic(\n        \"separation\", \n        10 ** (logarithmic_separation)\n    )\n\n    logarithmic_flux: float = npy.sample(\"logarithmic_flux\", dist.Uniform(4, 6))\n    flux: float = npy.deterministic(\"flux\", 10 ** logarithmic_flux)\n\n    logarithmic_contrast: float = npy.sample(\"logarithmic_contrast\", dist.Uniform(-4, 2))\n    contrast: float = npy.deterministic(\"contrast\", 10 ** logarithmic_contrast)\n\n    paths: list = [\n        \"BinarySource.position\",\n        \"BinarySource.separation\",\n        \"BinarySource.flux\",\n        \"BinarySource.contrast\",\n    ]\n\n    values: list = [\n        position,\n        separation,\n        flux,\n        contrast,\n    ]\n\n    with npy.plate(\"data\", len(fdata)):\n        poisson_model: float = dist.Poisson(\n            model.update_and_model(\"model\", paths, values, flatten=True)\n        )\n        return npy.sample(\"psf\", poisson_model, obs=fdata)\n</code></pre> <p>The function that we just designed is called the potential function by  <code>numpyro</code>. We can use this potential function to run various different  algorithms (MCMC mostly). In this case we want to use No-U-Turn Sampling (NUTS) since it is the best. We also get to chose how many chains (independent sets of samples) to run and how many samples should be in each chain. We get to  tune the number of warmup samples and the number of samples independently. The numbers I chose were mainly influenced by how long things took to run  rather than any careful analyses of the chains. </p> <p>Note</p> <p>I am not a statistician. I will, however, blithely claim that NUTS is  the best because it seems to be a popular opinion. I am vaguely aware  that it works very well on complex \"potentials\", but I will leave the  complex justification to others.</p> <pre><code>sampler = npy.infer.MCMC(\n    npy.infer.NUTS(hmc_model),    \n    num_warmup=500,\n    num_samples=500,\n    num_chains=1,\n    progress_bar=True,\n)\n</code></pre> <p>Now that everything about our model and analysis is nailed down we can  run the HMC. Running HMC will cause you to die inside. It takes a  long time and when it finally finishes there are a million ways things  can go wrong. Not the least of which, is unconstrained chains. Often these issues need to be addressed by changing the priors which means waiting  another 20min+ for the HMC to run, only to find out that you are still  not right.</p> <p>By passing in initial parameters near the global/local minima we can  make our lives easier. This is done by an appropriate selection of  <code>init_params</code>. While this is very useful for situations like this where  you already know the global minima, it is less useful in the field where  these things are unkown. I hear that a common pattern is to first use  gradient descent and them HMC starting from the local minima identified  by the gradient descent.</p> <p>Note</p> <p>My final piece of advice is to start the priors wide on purpose and slowly refine them until the chains converge.</p> <pre><code>sampler.run(jr.PRNGKey(0), model, init_params = model)\nsamples: float = sampler.get_samples().copy()\n</code></pre> <p>Note</p> <p>I copied the samples (<code>.copy</code>) because otherwise operations performed  on the samples would irrevocably destroy the original set of samples. This can mean that you have to re-run the algorthim just to visual  a new set of plots, which is really very inefficient.</p> <p>If you recall, we sampled our parameters in a roughly normalised space  first. We don't care about most of these normalised(ish) spaces and  certainly don't want to plot them. As a result we will remove them from  the <code>samples</code> dictionary using <code>pop</code>. Moreover, we are using <code>chainconsumer</code> for the plotting, which requires flat arrays. This means that position needs to be cast to <code>x</code> and <code>y</code> manually.</p> <pre><code>logarithmic_contrast_samples: float = samples.pop(\"logarithmic_contrast\")\nlogarithmic_flux_samples: float = samples.pop(\"logarithmic_flux\")\nlogarithmic_separation_samples: float = samples.pop(\"logarithmic_separation\")\nposition_in_pixels_samples: float = samples.pop(\"position_in_pixels\")\nsamples.update({\"x\": samples.get(\"position\")[:, 0], \"y\": samples.get(\"position\")[:, 1]})\nposition: float = samples.pop(\"position\")\n\nout: object = cc.ChainConsumer().add_chain(samples).plotter.plot()\n</code></pre> <p></p>"},{"location":"toliman/collections/","title":"Collections","text":""},{"location":"toliman/collections/#overview","title":"Overview","text":"<p>This file contains helpful functions for dealing with collections. You  will notice that I use <code>list</code> in the type annotations, although often  this can be relaxed to <code>iter</code>. This is of no significance to <code>python</code> and  any iterable collection may be used. The <code>CollectionInterface</code> is used to make it easier to deal with the optical systems defined in other files.</p>"},{"location":"toliman/collections/#api","title":"API","text":"<code>contains_instance</code> <p>Check to see if a list constains an element of a certain type.</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>list</code> <p>The list to search.</p> required <code>instance_of</code> <code>type</code> <p>The type to check for.</p> required <p>Returns:</p> Name Type Description <code>contains</code> <code>bool</code> <p>True if _type was found else False.</p> Source code in <code>toliman/collections.py</code> <pre><code>def contains_instance(collection: list, instance_of: type) -&gt; bool:\n\"\"\"\n    Check to see if a list constains an element of a certain type.\n\n    Parameters\n    ----------\n    collection: list\n        The list to search.\n    instance_of: type\n        The type to check for.\n\n    Returns\n    -------\n    contains: bool\n        True if _type was found else False.\n    \"\"\"\n    if collection:\n        for element in collection:\n            if isinstance(element, instance_of):\n                return True\n    return False\n</code></pre> <code>CollectionInterface</code> <p>         Bases: <code>abc.ABC</code></p> Source code in <code>toliman/collections.py</code> <pre><code>class CollectionInterface(abc.ABC):\n    @abc.abstractmethod\n    def to_optics_list(self: object) -&gt; list:\n\"\"\"\n        Get the optical elements that make up the object as a list.\n\n        Returns\n        -------\n        optics: list\n            The optical layers in order in a list.\n        \"\"\"\n\n    @abc.abstractmethod\n    def insert(self: object, optic: object, index: int) -&gt; object:\n\"\"\"\n        Add an additional layer to the optical system.\n\n        Parameters\n        ----------\n        optic: object\n            A `dLux.OpticalLayer` to include in the model.\n        index: int\n            Where in the list of layers to add optic.\n\n        Returns\n        -------\n        toliman: TolimanOptics\n            A new `TolimanOptics` instance with the applied update.\n        \"\"\"\n\n    @abc.abstractmethod\n    def remove(self: object, index: int) -&gt; object:\n\"\"\"\n        Take a layer from the optical system.\n\n        Parameters\n        ----------\n        index: int\n            Where in the list of layers to remove an optic.\n\n        Returns\n        -------\n        toliman: TolimanOptics\n            A new `TolimanOptics` instance with the applied update.\n        \"\"\"\n\n    @abc.abstractmethod\n    def append(self: object, optic: object) -&gt; object:\n\"\"\"\n        Place a new optic at the end of the optical system.\n\n        Parameters\n        ----------\n        optic: object\n            The optic to include. It must be a subclass of the\n            `dLux.OpticalLayer`.\n\n        Returns\n        -------\n        optics: object\n            The new optical system.\n        \"\"\"\n\n    @abc.abstractmethod\n    def pop(self: object) -&gt; object:\n\"\"\"\n        Remove the last element in the optical system.\n\n        Please note that this differs from the `.pop` method of the\n        `list` class because it does not return the popped element.\n\n        Returns\n        -------\n        optics: object\n            The optical system with the layer removed.\n        \"\"\"\n</code></pre>"},{"location":"toliman/collections/#toliman.collections.contains_instance","title":"Collections","text":""},{"location":"toliman/collections/#toliman.collections.CollectionInterface.append","title":"<code>append(optic)</code>  <code>abstractmethod</code>","text":"<p>Place a new optic at the end of the optical system.</p> <p>Parameters:</p> Name Type Description Default <code>optic</code> <code>object</code> <p>The optic to include. It must be a subclass of the <code>dLux.OpticalLayer</code>.</p> required <p>Returns:</p> Name Type Description <code>optics</code> <code>object</code> <p>The new optical system.</p> Source code in <code>toliman/collections.py</code> <pre><code>@abc.abstractmethod\ndef append(self: object, optic: object) -&gt; object:\n\"\"\"\n    Place a new optic at the end of the optical system.\n\n    Parameters\n    ----------\n    optic: object\n        The optic to include. It must be a subclass of the\n        `dLux.OpticalLayer`.\n\n    Returns\n    -------\n    optics: object\n        The new optical system.\n    \"\"\"\n</code></pre>"},{"location":"toliman/collections/#toliman.collections.CollectionInterface.insert","title":"<code>insert(optic, index)</code>  <code>abstractmethod</code>","text":"<p>Add an additional layer to the optical system.</p> <p>Parameters:</p> Name Type Description Default <code>optic</code> <code>object</code> <p>A <code>dLux.OpticalLayer</code> to include in the model.</p> required <code>index</code> <code>int</code> <p>Where in the list of layers to add optic.</p> required <p>Returns:</p> Name Type Description <code>toliman</code> <code>TolimanOptics</code> <p>A new <code>TolimanOptics</code> instance with the applied update.</p> Source code in <code>toliman/collections.py</code> <pre><code>@abc.abstractmethod\ndef insert(self: object, optic: object, index: int) -&gt; object:\n\"\"\"\n    Add an additional layer to the optical system.\n\n    Parameters\n    ----------\n    optic: object\n        A `dLux.OpticalLayer` to include in the model.\n    index: int\n        Where in the list of layers to add optic.\n\n    Returns\n    -------\n    toliman: TolimanOptics\n        A new `TolimanOptics` instance with the applied update.\n    \"\"\"\n</code></pre>"},{"location":"toliman/collections/#toliman.collections.CollectionInterface.pop","title":"<code>pop()</code>  <code>abstractmethod</code>","text":"<p>Remove the last element in the optical system.</p> <p>Please note that this differs from the <code>.pop</code> method of the <code>list</code> class because it does not return the popped element.</p> <p>Returns:</p> Name Type Description <code>optics</code> <code>object</code> <p>The optical system with the layer removed.</p> Source code in <code>toliman/collections.py</code> <pre><code>@abc.abstractmethod\ndef pop(self: object) -&gt; object:\n\"\"\"\n    Remove the last element in the optical system.\n\n    Please note that this differs from the `.pop` method of the\n    `list` class because it does not return the popped element.\n\n    Returns\n    -------\n    optics: object\n        The optical system with the layer removed.\n    \"\"\"\n</code></pre>"},{"location":"toliman/collections/#toliman.collections.CollectionInterface.remove","title":"<code>remove(index)</code>  <code>abstractmethod</code>","text":"<p>Take a layer from the optical system.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Where in the list of layers to remove an optic.</p> required <p>Returns:</p> Name Type Description <code>toliman</code> <code>TolimanOptics</code> <p>A new <code>TolimanOptics</code> instance with the applied update.</p> Source code in <code>toliman/collections.py</code> <pre><code>@abc.abstractmethod\ndef remove(self: object, index: int) -&gt; object:\n\"\"\"\n    Take a layer from the optical system.\n\n    Parameters\n    ----------\n    index: int\n        Where in the list of layers to remove an optic.\n\n    Returns\n    -------\n    toliman: TolimanOptics\n        A new `TolimanOptics` instance with the applied update.\n    \"\"\"\n</code></pre>"},{"location":"toliman/collections/#toliman.collections.CollectionInterface.to_optics_list","title":"<code>to_optics_list()</code>  <code>abstractmethod</code>","text":"<p>Get the optical elements that make up the object as a list.</p> <p>Returns:</p> Name Type Description <code>optics</code> <code>list</code> <p>The optical layers in order in a list.</p> Source code in <code>toliman/collections.py</code> <pre><code>@abc.abstractmethod\ndef to_optics_list(self: object) -&gt; list:\n\"\"\"\n    Get the optical elements that make up the object as a list.\n\n    Returns\n    -------\n    optics: list\n        The optical layers in order in a list.\n    \"\"\"\n</code></pre>"},{"location":"toliman/collections/#toliman.collections.CollectionInterface","title":"Collections","text":""},{"location":"toliman/collections/#toliman.collections.CollectionInterface.append","title":"Collections","text":""},{"location":"toliman/collections/#toliman.collections.CollectionInterface.insert","title":"Collections","text":""},{"location":"toliman/collections/#toliman.collections.CollectionInterface.pop","title":"Collections","text":""},{"location":"toliman/collections/#toliman.collections.CollectionInterface.remove","title":"Collections","text":""},{"location":"toliman/collections/#toliman.collections.CollectionInterface.to_optics_list","title":"Collections","text":""},{"location":"toliman/constants/","title":"Constants","text":""},{"location":"toliman/constants/#overview","title":"Overview","text":"<p><code>toliman</code> could have very, very many parameters. In the vast majority of use cases we will only care about a few of these so it didn't make sense  to force the user to mark the remainder as static. Instead I made many of  these potential parameters constant, for example, the radius of the pupil. There are other constants here as well, such as the metallicity of the  two stars in the binary and the default resolutions.</p> <p>By making them environment variables they can still be changed by the user. Because this code is evaluated when the package is imported this means that  changes to the constants need to be made from within <code>python</code> using the  <code>set_const</code> function. </p>"},{"location":"toliman/constants/#api","title":"API","text":"<code>set_const</code> <p>Set the value of an environment variable.</p> <p>Gives a warning if the constant already has a value. In  general it is not recommended that you change the values, but it may sometimes be necessary. </p> <p>Parameters:</p> Name Type Description Default <code>const</code> <code>str</code> <p>The name of the constant. See the documentation of use <code>list_consts</code> to view a complete list.</p> required <code>value</code> <code>object</code> <p>The value to assign to the constant.</p> required Source code in <code>toliman/constants.py</code> <pre><code>def set_const(const: str, value: object) -&gt; None:\n\"\"\"\n    Set the value of an environment variable.\n\n    Gives a warning if the constant already has a value. In \n    general it is not recommended that you change the values,\n    but it may sometimes be necessary. \n\n    Parameters\n    ----------\n    const: str \n        The name of the constant. See the documentation of use\n        `list_consts` to view a complete list.\n    value: object\n        The value to assign to the constant.\n    \"\"\"\n    if is_const_defined(const):\n        warnings.warn(\"`{}` was already defined.\".format(const))\n    os.environ[const] = str(value)\n</code></pre> <code>is_const_defined</code> <p>Check if an environment variable has been set.</p> <p>Parameters:</p> Name Type Description Default <code>const</code> <code>str</code> <p>The name of the constant.</p> required <p>Returns:</p> Name Type Description <code>defed</code> <code>bool</code> <p>True if the constant is defined, else False.</p> Source code in <code>toliman/constants.py</code> <pre><code>def is_const_defined(const: str) -&gt; bool:\n\"\"\"\n    Check if an environment variable has been set.\n\n    Parameters\n    ----------\n    const: str\n        The name of the constant.\n\n    Returns\n    -------\n    defed: bool\n        True if the constant is defined, else False.\n    \"\"\"\n    if os.environ.get(const):\n        return True\n    return False\n</code></pre> <code>get_const_as_type</code> <p>Retrieve a constant.</p> <p>Parameters:</p> Name Type Description Default <code>const</code> <code>str</code> <p>The name of the constant.</p> required <code>t</code> <code>type</code> <p>The type of the constant.</p> required <p>Returns:</p> Name Type Description <code>value</code> <code>t</code> <p>The value of the constant.</p> Source code in <code>toliman/constants.py</code> <pre><code>def get_const_as_type(const: str, t: type) -&gt; type:\n\"\"\"\n    Retrieve a constant.\n\n    Parameters\n    ----------\n    const: str\n        The name of the constant.\n    t: type\n        The type of the constant.\n\n    Returns\n    -------\n    value: t\n        The value of the constant.\n    \"\"\"\n    constant: str = os.environ[const]\n\n    if not constant.startswith(\"[\"):\n        return t(constant)\n\n    values: list = [\n        float(value.strip()) \n        for value in constant.strip(\"[\").strip(\"]\").split(\",\")\n    ]\n\n    return values\n</code></pre>"},{"location":"toliman/constants/#toliman.constants.set_const","title":"Constants","text":""},{"location":"toliman/constants/#toliman.constants.is_const_defined","title":"Constants","text":""},{"location":"toliman/constants/#toliman.constants.get_const_as_type","title":"Constants","text":""},{"location":"toliman/constants/#constants","title":"Constants","text":"Name Value Type Units <code>DEFAULT_PUPIL_NPIX</code> 256 <code>int</code> no. <code>DEFAULT_DETECTOR_NPIX</code> 128 <code>int</code> no. <code>DEFAULT_NUMBER_OF_ZERNIKES</code> 5 <code>int</code> no. <code>DEFAULT_MASK_DIR</code> $TOLIMAN_HOME/mask.npy <code>str</code> none <code>SPECTRUM_DIR</code> $TOLIMAN_HOME/spectra.csv <code>str</code> none <code>BACKGROUND_DIR</code> $TOLIMAN_HOME/background.csv <code>str</code> none <code>TOLIMAN_PRIMARY_APERTURE_DIAMETER</code> 0.13 <code>float</code> meters <code>TOLIMAN_SECONDARY_MIRROR_DIAMETER</code> 0.032 <code>float</code> meters <code>TOLIMAN_DETECTOR_PIXEL_SIZE</code> 0.375 <code>float</code> arcsec <code>TOLIMAN_WIDTH_OF_STRUTS</code> 0.01 <code>float</code> meters <code>TOLIMAN_NUMBER_OF_STRUTS</code> 3 <code>int</code> no. <code>DEFAULT_DETECTOR_JITTER</code> 2.0 <code>float</code> pixels <code>DEFAULT_DETECTOR_SATURATION</code> 2500 <code>int</code> photons <code>DEFAULT_DETECTOR_THRESHOLD</code> 0.05 <code>float</code> norm. <code>ALPHA_CENTAURI_SEPARATION</code> 8.0 <code>float</code> arcsec <code>ALPHA_CENTAURI_POSITION</code> [0.0, 0.0] <code>list</code> arcsec <code>ALPHA_CENTAURI_MEAN_FLUX</code> 1e5 <code>float</code> photons <code>ALPHA_CENTAURI_CONTRAST</code> 2.0 <code>float</code> none <code>ALPHA_CENTAURI_POSITION_ANGLE</code> 0.0 <code>float</code> radians <code>ALPHA_CEN_A_SURFACE_TEMP</code> 5790.0 <code>float</code> kelvin <code>ALPHA_CEN_A_METALICITY</code> 0.2 <code>float</code> norm. <code>ALPHA_CEN_A_SURFACE_GRAV</code> 4.0 <code>float</code> accel. <code>ALPHA_CEN_B_SURFACE_TEMP</code> 5260.0 <code>float</code> kelvin <code>ALPHA_CEN_B_METALICITY</code> 0.23 <code>float</code> norm. <code>ALPHA_CEN_B_SURFACE_GRAV</code> 4.37 <code>float</code> accel. <code>FILTER_MIN_WAVELENGTH</code> 595e-09 <code>float</code> meters <code>FILTER_MAX_WAVELENGTH</code> 695e-09 <code>float</code> meters <code>FILTER_DEFAULT_RES</code> 24 <code>int</code> no."},{"location":"toliman/io/","title":"Io","text":""},{"location":"toliman/io/#overview","title":"Overview","text":"<p><code>toliman</code> deals with a large number of data files, that need to be cast  into arrays. Some of these data files are <code>csv</code>s. Rather than add an  additional dependency like pandas, I wrote my own csv parser, designed  to be relatively simple. I tried to use <code>jax</code> as much as possible.  This was a stupid idea since the function cannot be compiled, since it  contains side effects. A slightly faster and more concise version of this function can be achieved using a list comprehension or the inbuilt <code>map</code> function. Regardless if it ain't broke don't fix it.</p>"},{"location":"toliman/io/#api","title":"API","text":"<code>read_csv_to_jax_array</code> <p>Read a CSV using <code>jax</code>.</p> <p>This is a private function and following convention it assumes that the  file exists. There is no error checking!</p> <p>Parameters:</p> Name Type Description Default <code>_file_name</code> <p>The name of the file to read.</p> required <p>Returns:</p> Name Type Description <code>arr</code> <code>float</code> <p>The information in the CSV. The headings are not returned and so it  is up to you to keep track of what each column is.</p> Source code in <code>toliman/io.py</code> <pre><code>def read_csv_to_jax_array(file_name: str) -&gt; float:\n\"\"\"\n    Read a CSV using `jax`.\n\n    This is a private function and following convention it assumes that the \n    file exists. There is no error checking!\n\n    Parameters\n    ----------\n    _file_name: str\n        The name of the file to read.\n\n    Returns\n    -------\n    arr: float\n        The information in the CSV. The headings are not returned and so it \n        is up to you to keep track of what each column is.\n    \"\"\"\n    with open(file_name, \"r\") as file:\n        lines: list = file.readlines()\n        _: str = lines.pop(0)\n        entries: list = jax.tree_map(strip, lines)\n        file: float = jax.tree_map(str_to_float, entries)\n    return np.array(file)\n</code></pre>"},{"location":"toliman/io/#toliman.io.read_csv_to_jax_array","title":"Io","text":""},{"location":"toliman/math/","title":"Math","text":""},{"location":"toliman/math/#overview","title":"Overview","text":"<p>This module contains a number of general functions that are useful in the  context of the toliman forwards model. Both <code>downsample</code> functions can  be used with mismatched shapes, but to do so removes the appropriate  amount from the left hand side of the image. Because, both functions  may be used in a <code>jit</code>ed context, side-effects i.e. warnings and errors are not used. Therefore, it is up to the user to ensure that they are  used correctly in contexts where they are information destroying. </p>"},{"location":"toliman/math/#api","title":"API","text":"<code>downsample_square_grid</code> <p>Resample a square array by a factor of <code>m</code>.</p> <p>Parameters:</p> Name Type Description Default <code>arr</code> <code>float</code> <p>An <code>NxN</code> array.</p> required <code>m</code> <p>The factor to downsample by so that the final shape is <code>(N/m)x(N/m)</code>. This implies that <code>N % m == 0</code>.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; import jax.numpy as np\n&gt;&gt;&gt; up_arr: float = np.ones((1024, 1024), dtype=float)\n&gt;&gt;&gt; down_arr: float = _downsample(arr, 4)\n&gt;&gt;&gt; down_arr.shape\n(256, 256)\n</code></pre> Source code in <code>toliman/math.py</code> <pre><code>def downsample_square_grid(arr: float, resample_by: int) -&gt; float:\n\"\"\"\n    Resample a square array by a factor of `m`.\n\n    Parameters\n    ----------\n    arr: float\n        An `NxN` array.\n    m: float\n        The factor to downsample by so that the final shape is `(N/m)x(N/m)`.\n        This implies that `N % m == 0`.\n\n    Examples\n    --------\n    ```python\n    &gt;&gt;&gt; import jax.numpy as np\n    &gt;&gt;&gt; up_arr: float = np.ones((1024, 1024), dtype=float)\n    &gt;&gt;&gt; down_arr: float = _downsample(arr, 4)\n    &gt;&gt;&gt; down_arr.shape\n    (256, 256)\n    ```\n    \"\"\"\n    shape_in: int = arr.shape[0]\n    shape_out: int = shape_in // resample_by\n    keep_from_left: int = shape_in - shape_in % resample_by\n    kept_array: float = arr[:keep_from_left, :keep_from_left]\n    kept_shape: int = kept_array.shape[0]\n\n    shape_for_first_sum: tuple = (kept_shape * shape_out, resample_by)\n    shape_for_second_sum: tuple = (shape_out * shape_out, resample_by) \n    sum_on_first_ax: float = kept_array.reshape(shape_for_first_sum).sum(1)\n    one_ax_summed: float = sum_on_first_ax.reshape(kept_shape, shape_out).T\n    sum_on_second_ax: float = one_ax_summed.reshape(shape_for_second_sum).sum(1)\n    summed: float = sum_on_second_ax.reshape(shape_out, shape_out).T\n\n    return summed / resample_by / resample_by\n</code></pre> <code>downsample_along_axis</code> <p>Resampling an array by averaging along a particular dimension.</p> <p>Parameters:</p> Name Type Description Default <code>arr</code> <code>float</code> <p>The array to resample.</p> required <code>resample_by</code> <code>int</code> <p>The factor by which to downsample the axis.</p> required <code>axis</code> <code>int</code> <p>The axis to resample.</p> <code>0</code> <p>Returns:</p> Name Type Description <code>arr</code> <code>float</code> <p>The resampled array</p> Source code in <code>toliman/math.py</code> <pre><code>def downsample_along_axis(arr: float, resample_by: int, axis: int = 0) -&gt; float:\n\"\"\"\n    Resampling an array by averaging along a particular dimension.\n\n    Parameters\n    ----------\n    arr: float\n        The array to resample.\n    resample_by: int\n        The factor by which to downsample the axis.\n    axis: int = 0\n        The axis to resample.\n\n    Returns\n    -------\n    arr: float\n        The resampled array\n    \"\"\"\n    shape: tuple = arr.shape\n    shape_along_ax_in: int = shape[axis]\n    shape_along_ax_out: int = shape_along_ax_in // resample_by\n    kept_along_ax: int = shape_along_ax_in - shape_along_ax_in % resample_by\n    axes: int = np.arange(arr.ndim, dtype = int)\n    trans: int = np.concatenate([np.array([axis]), axes[:axis], axes[(axis + 1):]])\n    trans_array: float = np.transpose(arr, trans)\n    kept_values: float = trans_array[:kept_along_ax]\n    back: int = np.concatenate([axes[1:axis + 1], np.array([0]), axes[axis + 1:]])\n    kept_array: float = np.transpose(kept_values, back)\n    shape_for_sum: tuple = shape[:axis] + (shape_along_ax_out,) + shape[axis + 1:] + (resample_by,)\n    return kept_array.reshape(shape_for_sum).sum(-1) / resample_by\n</code></pre> <code>simulate_data</code> <p>Simulate some fake sata for comparison.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <p>A model of the toliman. Should inherit from <code>dl.Instrument</code> or be an instance.</p> required <code>scale</code> <code>float</code> <p>How noisy is the detector?</p> required <p>Returns:</p> Name Type Description <code>data</code> <code>float, photons</code> <p>A noisy psf.</p> Source code in <code>toliman/math.py</code> <pre><code>def simulate_data(psf: float, scale: float) -&gt; float:\n\"\"\"\n    Simulate some fake sata for comparison.\n\n    Parameters\n    ----------\n    model: object\n        A model of the toliman. Should inherit from `dl.Instrument` or\n        be an instance.\n    scale: float\n        How noisy is the detector?\n\n    Returns\n    -------\n    data: float, photons\n        A noisy psf.\n    \"\"\"\n    noisy_psf: float = photon_noise(psf)\n    noisy_image: float = noisy_psf + latent_detector_noise(scale, psf.shape)\n    return noisy_image\n</code></pre> <code>pixel_response</code> <p>Simulate pixel reponses.</p> <p>Parameters:</p> Name Type Description Default <code>shape</code> <code>float</code> <p>The array shape to populate with a random pixel response.</p> required <code>threshold</code> <code>float</code> <p>How far from 1. does the pixel response typically vary.</p> required <code>seed</code> <code>int</code> <p>The seed of the random generation.</p> <code>1</code> <p>Returns:</p> Name Type Description <code>pixel_response</code> <code>float</code> <p>An array of the pixel responses.</p> Source code in <code>toliman/math.py</code> <pre><code>def pixel_response(shape: float, threshold: float, seed: int = 1) -&gt; float:\n\"\"\"\n    Simulate pixel reponses.\n\n    Parameters\n    ----------\n    shape: tuple[int]\n        The array shape to populate with a random pixel response.\n    threshold: float\n        How far from 1. does the pixel response typically vary.\n    seed: int = 1\n        The seed of the random generation.\n\n    Returns\n    -------\n    pixel_response: float\n        An array of the pixel responses.\n    \"\"\"\n    key: object = jax.random.PRNGKey(seed)\n    return 1.0 + threshold * jax.random.normal(key, shape)\n</code></pre> <code>photon_noise</code> <p>Simulate photon noise.</p> <p>Parameters:</p> Name Type Description Default <code>psf</code> <code>float</code> <p>The psf on which to add photon noise.</p> required <code>seed</code> <code>int</code> <p>The seed of the random generation.</p> <code>0</code> <p>Returns:</p> Name Type Description <code>photon_noise</code> <code>float</code> <p>A noisy psf.</p> Source code in <code>toliman/math.py</code> <pre><code>def photon_noise(psf: float, seed: int = 0) -&gt; float:\n\"\"\"\n    Simulate photon noise.\n\n    Parameters\n    ----------\n    psf: float\n        The psf on which to add photon noise.\n    seed: int = 1\n        The seed of the random generation.\n\n    Returns\n    -------\n    photon_noise: float\n        A noisy psf.\n    \"\"\"\n    key = jax.random.PRNGKey(seed)\n    return jax.random.poisson(key, psf)\n</code></pre> <code>latent_detector_noise</code> <p>Simulate some gaussian latent noise.</p> <p>Parameters:</p> Name Type Description Default <code>scale</code> <code>float</code> <p>The standard deviation of the gaussian in photons.</p> required <code>shape</code> <code>float</code> <p>The shape of the array to generate the noise on.</p> required <code>seed</code> <code>int</code> <p>The seed of the random generation.</p> <code>0</code> <p>Returns:</p> Name Type Description <code>det_noise</code> <code>float, photons</code> <p>The an additional noise source from the detector.</p> Source code in <code>toliman/math.py</code> <pre><code>def latent_detector_noise(scale: float, shape: float, seed: int = 0) -&gt; float:\n\"\"\"\n    Simulate some gaussian latent noise.\n\n    Parameters\n    ----------\n    scale: float, photons\n        The standard deviation of the gaussian in photons.\n    shape: tuple\n        The shape of the array to generate the noise on.\n    seed: int = 0\n        The seed of the random generation.\n\n    Returns\n    -------\n    det_noise: float, photons\n        The an additional noise source from the detector.\n    \"\"\"\n    key: object = jax.random.PRNGKey(seed)\n    return scale * jax.random.normal(key, shape)\n</code></pre> <code>normalise</code> <p>Rescale and array onto [0, 1].</p> <p>Parameters:</p> Name Type Description Default <code>arr</code> <code>float</code> <p>Any array.</p> required <p>Returns:</p> Name Type Description <code>arr</code> <code>float</code> <p>An array of floating point numbers over the range [0, 1].</p> Source code in <code>toliman/math.py</code> <pre><code>def normalise(arr: float) -&gt; float:\n\"\"\"\n    Rescale and array onto [0, 1].\n\n    Parameters\n    ----------\n    arr: float\n        Any array.\n\n    Returns\n    -------\n    arr: float\n        An array of floating point numbers over the range [0, 1].\n    \"\"\"\n    return (arr - arr.min()) / arr.ptp()\n</code></pre>"},{"location":"toliman/math/#toliman.math.downsample_square_grid","title":"Math","text":""},{"location":"toliman/math/#toliman.math.downsample_along_axis","title":"Math","text":""},{"location":"toliman/math/#toliman.math.simulate_data","title":"Math","text":""},{"location":"toliman/math/#toliman.math.pixel_response","title":"Math","text":""},{"location":"toliman/math/#toliman.math.photon_noise","title":"Math","text":""},{"location":"toliman/math/#toliman.math.latent_detector_noise","title":"Math","text":""},{"location":"toliman/math/#toliman.math.normalise","title":"Math","text":""},{"location":"toliman/toliman/","title":"Toliman","text":""},{"location":"toliman/toliman/#overview","title":"Overview","text":"<p>This file, amongst everything else contains the core optics of the <code>toliman</code>  forwards model. The basic concept is that each component of the model is  a specialisation (this is a type of inheritance) of a more general component. Deciding what level of detail to include was very arbitrary. In some senses, jut adding the pupil and the mask to the optics made the most sense as it  gave the user the freedom to add other layers as they saw fit. But, in the  end I decided that the simplest API was probably the best and so tried to  include as much detail as possible. This is something that might change as the model is used. The current model of the detector is a placeholder, since  the actual physical detector has not been selected. As a result we cannot  work with real values yet or include too much detail. </p> <p>There is a lot that can still be done with the forwards model, such as Fresnel calculations, secondary mirror polish and sidelobes. Unfortunately, I never got a chance to look into the sidelobes although it was high on my priority  list. The problem is that acurrately simulating the diffraction grating  requires very high sampling. In order to reduce the computation cost it was  proposed that we avoid as many layers as possible when simulating the sidelobes including only the aberrations. This then leads to complexity when considering  how to make sure that the aberrations are shared between the models. </p>"},{"location":"toliman/toliman/#api","title":"API","text":"<code>TolimanDetector</code> <p>         Bases: <code>dl.Detector</code>, <code>collections.CollectionInterface</code></p> <p>Represents the Toliman detector.</p> <p>A default implementation of a generic detector that is designed to be used with the <code>dLux.Instrument</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; toliman_detector: object = TolimanDetector()\n&gt;&gt;&gt; toliman_detector: object = TolimanDetector(simulate_jitter = False)\n</code></pre> Source code in <code>toliman/toliman.py</code> <pre><code>class TolimanDetector(dl.Detector, collections.CollectionInterface):\n\"\"\"\n    Represents the Toliman detector.\n\n    A default implementation of a generic detector that is designed\n    to be used with the `dLux.Instrument`.\n\n    Examples\n    --------\n    ```py\n    &gt;&gt;&gt; toliman_detector: object = TolimanDetector()\n    &gt;&gt;&gt; toliman_detector: object = TolimanDetector(simulate_jitter = False)\n    ```\n    \"\"\"\n\n    def __init__(\n        self: object,\n        simulate_jitter: bool = True,\n        simulate_pixel_response: bool = True,\n        simulate_saturation: bool = True,\n        extra_detector_layers: list = [],\n    ) -&gt; object:\n\"\"\"\n        Simulate the Toliman detector.\n\n        Parameters\n        ----------\n        simulate_jitter: bool = True\n            True if jitter should be included in the simulation of the\n            detector.\n        simulate_pixel_response: bool = True\n            True if a pixel response should be included in the simulation\n            of the detector.\n        simulate_saturation: bool = True\n            True if staturation should be included in the simulation of\n            the detector.\n        extra_detector_layers: list = []\n            Extra detector effects besides the default ones.\n        \"\"\"\n        DETECTOR_REPEATED_ERR_MSG = \"\"\"\n        You have provided a layer that is also a default layer. Make sure \n        that each type of detector is only provided once. \n        \"\"\"\n\n        DEFAULT_DETECTOR_JITTER: float = const.get_const_as_type(\"DEFAULT_DETECTOR_JITTER\", float)\n        DEFAULT_DETECTOR_SATURATION: float = const.get_const_as_type(\"DEFAULT_DETECTOR_SATURATION\", float)\n        DEFAULT_DETECTOR_NPIX: int = const.get_const_as_type(\"DEFAULT_DETECTOR_NPIX\", int)\n        DEFAULT_DETECTOR_THRESHOLD: float = const.get_const_as_type(\"DEFAULT_DETECTOR_THRESHOLD\", float)\n\n        detector_layers: list = []\n\n        if simulate_jitter:\n            detector_layers.append(dl.ApplyJitter(DEFAULT_DETECTOR_JITTER))\n\n            # TODO: Make a contains instance function\n            if collections.contains_instance(extra_detector_layers, dl.ApplyJitter):\n                raise ValueError(DETECTOR_REPEATED_ERR_MSG)\n\n        if simulate_saturation:\n            detector_layers.append(dl.ApplySaturation(DEFAULT_DETECTOR_SATURATION))\n\n            if collections.contains_instance(extra_detector_layers, dl.ApplySaturation):\n                raise ValueError(DETECTOR_REPEATED_ERR_MSG)\n\n        if simulate_pixel_response:\n            detector_layers.append(\n                dl.ApplyPixelResponse(\n                    math.pixel_response(\n                        (DEFAULT_DETECTOR_NPIX, DEFAULT_DETECTOR_NPIX),\n                        DEFAULT_DETECTOR_THRESHOLD,\n                    )\n                )\n            )\n\n            if collections.contains_instance(extra_detector_layers, dl.ApplyPixelResponse):\n                raise ValueError(DETECTOR_REPEATED_ERR_MSG)\n\n        detector_layers.extend(extra_detector_layers)\n\n        if detector_layers:\n            super().__init__(detector_layers)\n        else:\n            raise ValueError(\n                \"You have provided no detector layers and not asked \" +\\\n                \"for any of the defaults. This implies that the detector \" +\\\n                \"does not contain any layers which is not a valid state. \" +\\\n                \"If you do not wish to model any detector effects do not \" +\\\n                \"provide a detector in construction.\"\n            )\n\n    def to_optics_list(self: object) -&gt; list:\n\"\"\"\n        Get the optical elements that make up the object as a list.\n\n        Returns\n        -------\n        optics: list\n            The optical layers in order in a list.\n        \"\"\"\n        return list(self.layers.values())\n\n    def insert(self: object, optic: object, index: int) -&gt; object:\n\"\"\"\n        Add an additional layer to the optical system.\n\n        Parameters\n        ----------\n        optic: object\n            A `dLux.OpticalLayer` to include in the model.\n        index: int\n            Where in the list of layers to add optic.\n\n        Returns\n        -------\n        toliman: TolimanOptics\n            A new `TolimanOptics` instance with the applied update.\n        \"\"\"\n        if not isinstance(optic, dl.detectors.DetectorLayer):\n            raise ValueError(\"Inserted optics must be optical layers.\")\n\n        if index &lt; 0:\n            raise ValueError(\"`index` must be positive.\")\n\n        new_layers: list = self.to_optics_list()\n        length: int = len(new_layers)\n\n        if index &gt; length:\n            raise ValueError(\"`index` is outside the layers.\")\n\n        _: None = new_layers.insert(index, optic)\n        dl_new_layers: dict = dl.utils.list_to_dictionary(new_layers)\n        return eqx.tree_at(lambda x: x.layers, self, dl_new_layers)\n\n    def remove(self: object, index: int) -&gt; object:\n\"\"\"\n        Take a layer from the optical system.\n\n        Parameters\n        ----------\n        index: int\n            Where in the list of layers to remove an optic.\n\n        Returns\n        -------\n        toliman: TolimanOptics\n            A new `TolimanOptics` instance with the applied update.\n        \"\"\"\n        if index &lt; 0:\n            raise ValueError(\"`index` must be positive.\")\n\n        new_layers: list = self.to_optics_list()\n        length: int = len(new_layers)\n\n        if index &gt; length:\n            raise ValueError(\"`index` must be within the detector.\")\n\n        _: None = new_layers.pop(index)\n        dl_new_layers: dict = dl.utils.list_to_dictionary(new_layers)\n        return eqx.tree_at(lambda x: x.layers, self, dl_new_layers)\n\n    def append(self: object, optic: object) -&gt; object:\n\"\"\"\n        Place a new optic at the end of the optical system.\n\n        Parameters\n        ----------\n        optic: object\n            The optic to include. It must be a subclass of the\n            `dLux.OpticalLayer`.\n\n        Returns\n        -------\n        optics: object\n            The new optical system.\n        \"\"\"\n        if not isinstance(optic, dl.detectors.DetectorLayer):\n            raise ValueError(\"Inserted optics must be a detector layer.\")\n\n        new_layers: list = self.to_optics_list()\n        _: None = new_layers.append(optic)\n        dl_new_layers: dict = dl.utils.list_to_dictionary(new_layers)\n        return eqx.tree_at(lambda x: x.layers, self, dl_new_layers)\n\n    def pop(self: object) -&gt; object:\n\"\"\"\n        Remove the last element in the optical system.\n\n        Please note that this differs from the `.pop` method of\n        the `list` class  because it does not return the popped element.\n\n        Returns\n        -------\n        optics: object\n            The optical system with the layer removed.\n        \"\"\"\n        new_layers: list = self.to_optics_list()\n        _: object = new_layers.pop()\n        dl_new_layers: dict = dl.utils.list_to_dictionary(new_layers)\n        return eqx.tree_at(lambda x: x.layers, self, dl_new_layers)\n</code></pre> <code>TolimanOptics</code> <p>         Bases: <code>dl.Optics</code>, <code>collections.CollectionInterface</code></p> <p>Simulates the optical system of the TOLIMAN telescope.</p> <p>It is designed to occupy the <code>optics</code> kwarg of <code>dl.Instrument</code>. The <code>TolimanOptics</code> provides a default implementation that can be extended using the <code>.add</code> method. There are also several ways that the <code>TolimanOptics</code> can be initialised.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; toliman_optics: object = TolimanOptics()\n&gt;&gt;&gt; toliman_optics: object = TolimanOptics(simulate_aberrations = False)\n&gt;&gt;&gt; toliman_optics: object = TolimanOptics(pixels_in_pupil = 1024)\n</code></pre> <p>For more options run <code>help(TolimanOptics.__init__)</code>.</p> Source code in <code>toliman/toliman.py</code> <pre><code>class TolimanOptics(dl.Optics, collections.CollectionInterface):\n\"\"\"\n    Simulates the optical system of the TOLIMAN telescope.\n\n    It is designed to occupy the `optics` kwarg of `dl.Instrument`.\n    The `TolimanOptics` provides a default implementation that\n    can be extended using the `.add` method. There are also\n    several ways that the `TolimanOptics` can be initialised.\n\n    Examples\n    --------\n    ```\n    &gt;&gt;&gt; toliman_optics: object = TolimanOptics()\n    &gt;&gt;&gt; toliman_optics: object = TolimanOptics(simulate_aberrations = False)\n    &gt;&gt;&gt; toliman_optics: object = TolimanOptics(pixels_in_pupil = 1024)\n    ```\n\n    For more options run `help(TolimanOptics.__init__)`.\n    \"\"\"\n\n    def __init__(\n        self: object,\n        simulate_polish: bool = False,\n        simulate_aberrations: bool = True,\n        operate_in_fresnel_mode: bool = False,\n        operate_in_static_mode: bool = True,\n        number_of_zernikes: int = int(os.environ[\"DEFAULT_NUMBER_OF_ZERNIKES\"]),\n        pixels_in_pupil: int = int(os.environ[\"DEFAULT_PUPIL_NPIX\"]),\n        pixels_on_detector: int = int(os.environ[\"DEFAULT_DETECTOR_NPIX\"]),\n        path_to_mask: str = os.environ[\"DEFAULT_MASK_DIR\"],\n        path_to_filter: str = \"assets/filter.npy\",\n        path_to_polish: str = \"assets/polish.npy\",\n    ) -&gt; object:\n\"\"\"\n        Simulate the Toliman telescope.\n\n        Parameters\n        ----------\n        simulate_polish: bool = True\n            True if a layer should be included simulating the polish\n            on the secondary mirror.\n        simulate_aberrations: bool = True\n            True if the aberrations should be included.\n        operate_in_fresnel_mode: bool = False\n            True if the simulation should use Fresnel instead of\n            Fourier optics.\n        operate_in_static_mode: bool = True\n            True if the pupil of the aperture should be modelled\n            as static. This will improve performance so only change\n            it if you want to learn a parameter of the aperture.\n        number_of_zernikes: int = DEFAULT_NUMBER_OF_ZERNIKES\n            The number of zernike polynomials that should be used\n            to model the aberrations.\n        pixels_in_pupil: int = DEFAULT_PUPIL_NPIX\n            The number of pixels in the pupil plane.\n        pixels_on_detector: int = DEFAULT_DETECTOR_NPIX\n            The number of pixels in the detector plane.\n        path_to_mask: str = \"assets/mask.npy\"\n            The file location of a `.npy` file that contains an\n            array representation o the mask.\n        path_to_filter: str = \"assets/filter.npy\"\n            The file location of a `.npy` file that contains an\n            array representation og the filter.\n        path_to_polish: str = \"assets/polish.npy\"\n            The file location of a `.npy` file that contains an\n            array representation of the secondary mirror polish.\n        \"\"\"\n        PRIMARY_APERTURE_DIAMETER: float = const.get_const_as_type(\"TOLIMAN_PRIMARY_APERTURE_DIAMETER\", float)\n        NUMBER_OF_STRUTS: int = const.get_const_as_type(\"TOLIMAN_NUMBER_OF_STRUTS\", int)\n        WIDTH_OF_STRUTS: float = const.get_const_as_type(\"TOLIMAN_WIDTH_OF_STRUTS\", float)\n        SECONDARY_MIRROR_DIAMETER: float = const.get_const_as_type(\"TOLIMAN_SECONDARY_MIRROR_DIAMETER\", float)\n        DETECTOR_PIXEL_SIZE: int = const.get_const_as_type(\"TOLIMAN_DETECTOR_PIXEL_SIZE\", float)\n\n        toliman_layers: list = [\n            dl.CreateWavefront(\n                pixels_in_pupil,\n                PRIMARY_APERTURE_DIAMETER,\n                wavefront_type=\"Angular\",\n            )\n        ]\n\n        # Adding the pupil\n        dyn_toliman_pupil: object = dl.CompoundAperture(\n            [\n                dl.UniformSpider(NUMBER_OF_STRUTS, WIDTH_OF_STRUTS),\n                dl.AnnularAperture(\n                    PRIMARY_APERTURE_DIAMETER / 2.0,\n                    SECONDARY_MIRROR_DIAMETER / 2.0,\n                ),\n            ]\n        )\n\n        if operate_in_static_mode:\n            static_toliman_pupil: object = dl.StaticAperture(\n                dyn_toliman_pupil,\n                npixels=pixels_in_pupil,\n                diameter=PRIMARY_APERTURE_DIAMETER,\n            )\n\n            toliman_layers.append(static_toliman_pupil)\n        else:\n            toliman_layers.append(dyn_toliman_pupil)\n\n        # Loading the mask.\n        try:\n            loaded_mask: float = np.load(path_to_mask)\n            loaded_shape: tuple = loaded_mask.shape\n            loaded_width: int = loaded_shape[0]\n\n            mask: float\n            if not loaded_width == pixels_in_pupil:\n                if loaded_width &lt; pixels_in_pupil:\n                    raise NotImplementedError( \n                        \"The mask you have loaded had a higher resolution \" +\\\n                        \"than the pupil. A method of resolving this has not \" +\\\n                        \"yet been created. Either change the value of the \" +\\\n                        \"`DEFAULT_PUPIL_NPIX` constant or use a different mask.\"\n                    )\n                if loaded_width % pixels_in_pupil == 0:\n                    downsample_by: int = loaded_width // pixels_in_pupil\n                    mask: float = math.downsample_square_grid(loaded_mask, downsample_by)\n                else:\n                    raise ValueError(\n                        \"The mask you have loaded could not be downsampled \" +\\\n                        \"onto the pupil. The shape of the mask was \" +\\\n                        \"({%i, %i}). Either change the value of the \"\n                        \"environment variable `DEFAULT_PUPIL_NPIX` or use \" +\\\n                        \"a different mask.\".format(loaded_width, loaded_width)\n                    )\n            else:\n                mask: float = loaded_mask\n\n            del loaded_mask\n            del loaded_shape\n            del loaded_width\n        except IOError as ioe:\n            raise ValueError(\n                \"The file address that of the mask did not exist. \" +\\\n                \"Make sure that you have a `.npy` representation of the \" +\\\n                \"phase mask available and have provided the correct file \" +\\\n                \"address to the constructor.\"\n            )\n\n        toliman_layers.append(dl.AddOPD(mask))\n\n        # Generating the Zernikes\n        # TODO: Make zernike_coefficients a function\n        if simulate_aberrations:\n            nolls: list = np.arange(2, number_of_zernikes + 2, dtype=int)\n            seed: object = jax.random.PRNGKey(0)\n            coeffs: list = 1e-08 * jax.random.normal(seed, (number_of_zernikes,))\n\n            toliman_aberrations: object = dl.StaticAberratedAperture(\n                dl.AberratedAperture(\n                    noll_inds=nolls,\n                    coefficients=coeffs,\n                    aperture=dl.CircularAperture(\n                        PRIMARY_APERTURE_DIAMETER / 2.0\n                    ),\n                ),\n                npixels=pixels_in_pupil,\n                diameter=PRIMARY_APERTURE_DIAMETER,\n            )\n\n            toliman_layers.append(toliman_aberrations)\n\n        toliman_layers.append(dl.NormaliseWavefront())\n\n        if simulate_polish:\n            raise NotImplementedError(\n                \"You have requested that the mirror polish be simulated \" +\\\n                \"this has not yet been implemented although it is planned \" +\\\n                \"in an upcoming release.\"\n            )\n\n        # Adding the propagator\n        toliman_body: object\n        if not operate_in_fresnel_mode:\n            toliman_body: object = dl.AngularMFT(\n                pixels_on_detector, DETECTOR_PIXEL_SIZE\n            )\n        else:\n            raise NotImplementedError(\n                \"You have request operation in Fresenl mode. This has \" +\\\n                \"not currently been implemented. Once implemented it \" +\\\n                \"is not recommended that you use the feature as it is \" +\\\n                \"very slow and the zernike terms should be sufficient for \" +\\\n                \"most purposes.\"\n            )\n\n        toliman_layers.append(toliman_body)\n\n        # Renormalising the flux.\n        toliman_layers.append(dl.NormaliseWavefront())\n\n        super().__init__(layers=toliman_layers)\n\n    def to_optics_list(self: object) -&gt; list:\n\"\"\"\n        Get the optical elements that make up the object as a list.\n\n        Returns\n        -------\n        optics: list\n            The optical layers in order in a list.\n        \"\"\"\n        return list(self.layers.values())\n\n    def insert(self: object, optic: object, index: int) -&gt; object:\n\"\"\"\n        Add an additional layer to the optical system.\n\n        Parameters\n        ----------\n        optic: object\n            A `dLux.OpticalLayer` to include in the model.\n        index: int\n            Where in the list of layers to add optic.\n\n        Returns\n        -------\n        toliman: TolimanOptics\n            A new `TolimanOptics` instance with the applied update.\n        \"\"\"\n        correct_type: bool = False\n        if isinstance(optic, dl.optics.OpticalLayer):\n            correct_type: bool = True\n        elif isinstance(optic, dl.apertures.ApertureLayer):\n            correct_type: bool = True\n\n        if not correct_type:\n            raise ValueError(\"Inserted optics must be optical layers.\")\n\n        if index &lt; 0:\n            raise ValueError(\"`index` must be positive.\")\n\n        new_layers: list = self.to_optics_list()\n        _: None = new_layers.insert(index, optic)\n        dl_new_layers: dict = dl.utils.list_to_dictionary(new_layers)\n        return eqx.tree_at(lambda x: x.layers, self, dl_new_layers)\n\n    def remove(self: object, index: int) -&gt; object:\n\"\"\"\n        Take a layer from the optical system.\n\n        Parameters\n        ----------\n        index: int\n            Where in the list of layers to remove an optic.\n\n        Returns\n        -------\n        toliman: TolimanOptics\n            A new `TolimanOptics` instance with the applied update.\n        \"\"\"\n        if index &lt; 0:\n            raise ValueError(\"`index` must be positive.\")\n\n        new_layers: list = self.to_optics_list()\n        length: int = len(new_layers)\n\n        if index &gt; length:\n            raise ValueError(\"`index` must be within the optical system.\")\n\n        _: None = new_layers.pop(index)\n        dl_new_layers: dict = dl.utils.list_to_dictionary(new_layers)\n        return eqx.tree_at(lambda x: x.layers, self, dl_new_layers)\n\n    def append(self: object, optic: object) -&gt; object:\n\"\"\"\n        Place a new optic at the end of the optical system.\n\n        Parameters\n        ----------\n        optic: object\n            The optic to include. It must be a subclass of the\n            `dLux.OpticalLayer`.\n\n        Returns\n        -------\n        optics: object\n            The new optical system.\n        \"\"\"\n        correct_type: bool = False\n        if isinstance(optic, dl.optics.OpticalLayer):\n            correct_type: bool = True\n        elif isinstance(optic, dl.apertures.ApertureLayer):\n            correct_type: bool = True\n\n        if not correct_type:\n            raise ValueError(\"Inserted optics must be optical layers.\")\n\n        new_layers: list = self.to_optics_list()\n        _: None = new_layers.append(optic)\n        dl_new_layers: dict = dl.utils.list_to_dictionary(new_layers)\n        return eqx.tree_at(lambda x: x.layers, self, dl_new_layers)\n\n    def pop(self: object) -&gt; object:\n\"\"\"\n        Remove the last element in the optical system.\n\n        Please note that this differs from the `.pop` method of\n        the `list` class  because it does not return the popped element.\n\n        Returns\n        -------\n        optics: object\n            The optical system with the layer removed.\n        \"\"\"\n        new_layers: list = self.to_optics_list()\n        _: object = new_layers.pop()\n        dl_new_layers: dict = dl.utils.list_to_dictionary(new_layers)\n        return eqx.tree_at(lambda x: x.layers, self, dl_new_layers)\n</code></pre> <code>AlphaCentauri</code> <p>         Bases: <code>dl.BinarySource</code></p> <p>A convinient representation of the Alpha Centauri binary system.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; alpha_cen: object = AlphaCentauri()\n&gt;&gt;&gt; wavelengths: float = 1e-09 * np.linspace(595., 695., 10)\n&gt;&gt;&gt; fluxes: float = np.ones((10,), dtype = float)\n&gt;&gt;&gt; spectrum: object = dl.ArraySpectrum(wavelengths, fluxes)\n&gt;&gt;&gt; alpha_cen: object = AlphaCentauri(spectrum = spectrum)\n</code></pre> Source code in <code>toliman/toliman.py</code> <pre><code>class AlphaCentauri(dl.BinarySource):\n\"\"\"\n    A convinient representation of the Alpha Centauri binary system.\n\n    Examples\n    --------\n    ```python\n    &gt;&gt;&gt; alpha_cen: object = AlphaCentauri()\n    &gt;&gt;&gt; wavelengths: float = 1e-09 * np.linspace(595., 695., 10)\n    &gt;&gt;&gt; fluxes: float = np.ones((10,), dtype = float)\n    &gt;&gt;&gt; spectrum: object = dl.ArraySpectrum(wavelengths, fluxes)\n    &gt;&gt;&gt; alpha_cen: object = AlphaCentauri(spectrum = spectrum)\n    ```\n    \"\"\"\n\n    def __init__(self: object, spectrum: float = None) -&gt; object:\n\"\"\"\n        Simulate Alpha Centauri.\n\n        Parameters\n        ----------\n        spectrum: float = None\n            A `dl.Spectrum` if the default is not to be used. Recall\n            that the convinience method `_simulate_alpha_cen_spectrum`\n            can be used to simulate the spectrum.\n        \"\"\"\n        SPECTRUM_DIR: str = const.get_const_as_type(\"SPECTRUM_DIR\", str) \n\n        if not spectrum:\n            _spectrum: float = io.read_csv_to_jax_array(SPECTRUM_DIR) \n\n            alpha_cen_a_waves: float = _spectrum[:, 0]\n            alpha_cen_b_waves: float = _spectrum[:, 2]\n            alpha_cen_a_flux: float = _spectrum[:, 1]\n            alpha_cen_b_flux: float = _spectrum[:, 3]\n\n            alpha_cen_waves: float = np.stack([alpha_cen_a_waves, alpha_cen_b_waves])\n            alpha_cen_flux: float = np.stack([alpha_cen_a_flux, alpha_cen_b_flux])\n\n            spectrum: float = dl.CombinedSpectrum(\n                wavelengths=alpha_cen_waves, weights=alpha_cen_flux\n            )\n\n        ALPHA_CENTAURI_POSITION: float = const.get_const_as_type(\"ALPHA_CENTAURI_POSITION\", np.array)\n        ALPHA_CENTAURI_MEAN_FLUX: float = const.get_const_as_type(\"ALPHA_CENTAURI_MEAN_FLUX\", float)\n        ALPHA_CENTAURI_CONTRAST: float = const.get_const_as_type(\"ALPHA_CENTAURI_CONTRAST\", float)\n        ALPHA_CENTAURI_SEPARATION: float = const.get_const_as_type(\"ALPHA_CENTAURI_SEPARATION\", float)\n        ALPHA_CENTAURI_POSITION_ANGLE: float = const.get_const_as_type(\"ALPHA_CENTAURI_POSITION_ANGLE\", float)\n\n        super().__init__(\n            position=ALPHA_CENTAURI_POSITION,\n            flux=ALPHA_CENTAURI_MEAN_FLUX,\n            contrast=ALPHA_CENTAURI_CONTRAST,\n            separation=ALPHA_CENTAURI_SEPARATION,\n            position_angle=ALPHA_CENTAURI_POSITION_ANGLE,\n            spectrum=spectrum,\n        )\n</code></pre> <code>Background</code> <p>         Bases: <code>dl.MultiPointSource</code></p> <p>Simplies the creation of a sample of background stars.</p> <p>The sample of background stars is pulled from the Gaia database but there is some voodoo involved in regularising the data. Use the <code>_simulate_background_stars</code> function to generate alternative samples.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; bg: object = Background()\n&gt;&gt;&gt; lim_bg: object = Background(number_of_bg_stars = 10)\n</code></pre> Source code in <code>toliman/toliman.py</code> <pre><code>class Background(dl.MultiPointSource):\n\"\"\"\n    Simplies the creation of a sample of background stars.\n\n    The sample of background stars is pulled from the Gaia database\n    but there is some voodoo involved in regularising the data.\n    Use the `_simulate_background_stars` function to generate\n    alternative samples.\n\n    Examples\n    --------\n    ```python\n    &gt;&gt;&gt; bg: object = Background()\n    &gt;&gt;&gt; lim_bg: object = Background(number_of_bg_stars = 10)\n    ```\n    \"\"\"\n\n    def __init__(\n        self: object, number_of_bg_stars: int = None, spectrum: object = None\n    ) -&gt; object:\n\"\"\"\n        Simulate background stars.\n\n        Parameters\n        ----------\n        number_of_bg_stars: int = None\n            How many background stars should be simulated.\n        spectrum: object = None\n            A `dl.Spectrum` if the default spectrum is not to be used.\n        \"\"\"\n        FILTER_MIN_WAVELENGTH: float = const.get_const_as_type(\"FILTER_MIN_WAVELENGTH\", float)\n        FILTER_MAX_WAVELENGTH: float = const.get_const_as_type(\"FILTER_MAX_WAVELENGTH\", float)\n        BG_DEF_SPEC_RES: int = const.get_const_as_type(\"BACKGROUND_STAR_SPEC_RES\", int)\n        BACKGROUND_DIR: str = const.get_const_as_type(\"BACKGROUND_DIR\", str) \n\n        if not spectrum:\n            spectrum: object = dl.ArraySpectrum(\n                wavelengths=np.linspace(\n                    FILTER_MIN_WAVELENGTH, FILTER_MAX_WAVELENGTH, BG_DEF_SPEC_RES\n                ),\n                weights=np.ones((BG_DEF_SPEC_RES,), dtype=float),\n            )\n\n        # TODO: Better error handling if BACKGROUND_DIR is not valid\n        _background: float = io.read_csv_to_jax_array(BACKGROUND_DIR)\n\n        if number_of_bg_stars:\n            select_by: int = _background.shape[0] // number_of_bg_stars\n            _background: float = _background[::select_by, :]\n\n        position: float = np.pi / 180 * _background[:, (0, 1)]\n        flux: float = 1e5 * _background[:, 2]\n\n        super().__init__(position=position, flux=flux, spectrum=spectrum)\n</code></pre>"},{"location":"toliman/toliman/#toliman.toliman.TolimanDetector.__init__","title":"<code>__init__(simulate_jitter=True, simulate_pixel_response=True, simulate_saturation=True, extra_detector_layers=[])</code>","text":"<p>Simulate the Toliman detector.</p> <p>Parameters:</p> Name Type Description Default <code>simulate_jitter</code> <code>bool</code> <p>True if jitter should be included in the simulation of the detector.</p> <code>True</code> <code>simulate_pixel_response</code> <code>bool</code> <p>True if a pixel response should be included in the simulation of the detector.</p> <code>True</code> <code>simulate_saturation</code> <code>bool</code> <p>True if staturation should be included in the simulation of the detector.</p> <code>True</code> <code>extra_detector_layers</code> <code>list</code> <p>Extra detector effects besides the default ones.</p> <code>[]</code> Source code in <code>toliman/toliman.py</code> <pre><code>def __init__(\n    self: object,\n    simulate_jitter: bool = True,\n    simulate_pixel_response: bool = True,\n    simulate_saturation: bool = True,\n    extra_detector_layers: list = [],\n) -&gt; object:\n\"\"\"\n    Simulate the Toliman detector.\n\n    Parameters\n    ----------\n    simulate_jitter: bool = True\n        True if jitter should be included in the simulation of the\n        detector.\n    simulate_pixel_response: bool = True\n        True if a pixel response should be included in the simulation\n        of the detector.\n    simulate_saturation: bool = True\n        True if staturation should be included in the simulation of\n        the detector.\n    extra_detector_layers: list = []\n        Extra detector effects besides the default ones.\n    \"\"\"\n    DETECTOR_REPEATED_ERR_MSG = \"\"\"\n    You have provided a layer that is also a default layer. Make sure \n    that each type of detector is only provided once. \n    \"\"\"\n\n    DEFAULT_DETECTOR_JITTER: float = const.get_const_as_type(\"DEFAULT_DETECTOR_JITTER\", float)\n    DEFAULT_DETECTOR_SATURATION: float = const.get_const_as_type(\"DEFAULT_DETECTOR_SATURATION\", float)\n    DEFAULT_DETECTOR_NPIX: int = const.get_const_as_type(\"DEFAULT_DETECTOR_NPIX\", int)\n    DEFAULT_DETECTOR_THRESHOLD: float = const.get_const_as_type(\"DEFAULT_DETECTOR_THRESHOLD\", float)\n\n    detector_layers: list = []\n\n    if simulate_jitter:\n        detector_layers.append(dl.ApplyJitter(DEFAULT_DETECTOR_JITTER))\n\n        # TODO: Make a contains instance function\n        if collections.contains_instance(extra_detector_layers, dl.ApplyJitter):\n            raise ValueError(DETECTOR_REPEATED_ERR_MSG)\n\n    if simulate_saturation:\n        detector_layers.append(dl.ApplySaturation(DEFAULT_DETECTOR_SATURATION))\n\n        if collections.contains_instance(extra_detector_layers, dl.ApplySaturation):\n            raise ValueError(DETECTOR_REPEATED_ERR_MSG)\n\n    if simulate_pixel_response:\n        detector_layers.append(\n            dl.ApplyPixelResponse(\n                math.pixel_response(\n                    (DEFAULT_DETECTOR_NPIX, DEFAULT_DETECTOR_NPIX),\n                    DEFAULT_DETECTOR_THRESHOLD,\n                )\n            )\n        )\n\n        if collections.contains_instance(extra_detector_layers, dl.ApplyPixelResponse):\n            raise ValueError(DETECTOR_REPEATED_ERR_MSG)\n\n    detector_layers.extend(extra_detector_layers)\n\n    if detector_layers:\n        super().__init__(detector_layers)\n    else:\n        raise ValueError(\n            \"You have provided no detector layers and not asked \" +\\\n            \"for any of the defaults. This implies that the detector \" +\\\n            \"does not contain any layers which is not a valid state. \" +\\\n            \"If you do not wish to model any detector effects do not \" +\\\n            \"provide a detector in construction.\"\n        )\n</code></pre>"},{"location":"toliman/toliman/#toliman.toliman.TolimanDetector.append","title":"<code>append(optic)</code>","text":"<p>Place a new optic at the end of the optical system.</p> <p>Parameters:</p> Name Type Description Default <code>optic</code> <code>object</code> <p>The optic to include. It must be a subclass of the <code>dLux.OpticalLayer</code>.</p> required <p>Returns:</p> Name Type Description <code>optics</code> <code>object</code> <p>The new optical system.</p> Source code in <code>toliman/toliman.py</code> <pre><code>def append(self: object, optic: object) -&gt; object:\n\"\"\"\n    Place a new optic at the end of the optical system.\n\n    Parameters\n    ----------\n    optic: object\n        The optic to include. It must be a subclass of the\n        `dLux.OpticalLayer`.\n\n    Returns\n    -------\n    optics: object\n        The new optical system.\n    \"\"\"\n    if not isinstance(optic, dl.detectors.DetectorLayer):\n        raise ValueError(\"Inserted optics must be a detector layer.\")\n\n    new_layers: list = self.to_optics_list()\n    _: None = new_layers.append(optic)\n    dl_new_layers: dict = dl.utils.list_to_dictionary(new_layers)\n    return eqx.tree_at(lambda x: x.layers, self, dl_new_layers)\n</code></pre>"},{"location":"toliman/toliman/#toliman.toliman.TolimanDetector.insert","title":"<code>insert(optic, index)</code>","text":"<p>Add an additional layer to the optical system.</p> <p>Parameters:</p> Name Type Description Default <code>optic</code> <code>object</code> <p>A <code>dLux.OpticalLayer</code> to include in the model.</p> required <code>index</code> <code>int</code> <p>Where in the list of layers to add optic.</p> required <p>Returns:</p> Name Type Description <code>toliman</code> <code>TolimanOptics</code> <p>A new <code>TolimanOptics</code> instance with the applied update.</p> Source code in <code>toliman/toliman.py</code> <pre><code>def insert(self: object, optic: object, index: int) -&gt; object:\n\"\"\"\n    Add an additional layer to the optical system.\n\n    Parameters\n    ----------\n    optic: object\n        A `dLux.OpticalLayer` to include in the model.\n    index: int\n        Where in the list of layers to add optic.\n\n    Returns\n    -------\n    toliman: TolimanOptics\n        A new `TolimanOptics` instance with the applied update.\n    \"\"\"\n    if not isinstance(optic, dl.detectors.DetectorLayer):\n        raise ValueError(\"Inserted optics must be optical layers.\")\n\n    if index &lt; 0:\n        raise ValueError(\"`index` must be positive.\")\n\n    new_layers: list = self.to_optics_list()\n    length: int = len(new_layers)\n\n    if index &gt; length:\n        raise ValueError(\"`index` is outside the layers.\")\n\n    _: None = new_layers.insert(index, optic)\n    dl_new_layers: dict = dl.utils.list_to_dictionary(new_layers)\n    return eqx.tree_at(lambda x: x.layers, self, dl_new_layers)\n</code></pre>"},{"location":"toliman/toliman/#toliman.toliman.TolimanDetector.pop","title":"<code>pop()</code>","text":"<p>Remove the last element in the optical system.</p> <p>Please note that this differs from the <code>.pop</code> method of the <code>list</code> class  because it does not return the popped element.</p> <p>Returns:</p> Name Type Description <code>optics</code> <code>object</code> <p>The optical system with the layer removed.</p> Source code in <code>toliman/toliman.py</code> <pre><code>def pop(self: object) -&gt; object:\n\"\"\"\n    Remove the last element in the optical system.\n\n    Please note that this differs from the `.pop` method of\n    the `list` class  because it does not return the popped element.\n\n    Returns\n    -------\n    optics: object\n        The optical system with the layer removed.\n    \"\"\"\n    new_layers: list = self.to_optics_list()\n    _: object = new_layers.pop()\n    dl_new_layers: dict = dl.utils.list_to_dictionary(new_layers)\n    return eqx.tree_at(lambda x: x.layers, self, dl_new_layers)\n</code></pre>"},{"location":"toliman/toliman/#toliman.toliman.TolimanDetector.remove","title":"<code>remove(index)</code>","text":"<p>Take a layer from the optical system.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Where in the list of layers to remove an optic.</p> required <p>Returns:</p> Name Type Description <code>toliman</code> <code>TolimanOptics</code> <p>A new <code>TolimanOptics</code> instance with the applied update.</p> Source code in <code>toliman/toliman.py</code> <pre><code>def remove(self: object, index: int) -&gt; object:\n\"\"\"\n    Take a layer from the optical system.\n\n    Parameters\n    ----------\n    index: int\n        Where in the list of layers to remove an optic.\n\n    Returns\n    -------\n    toliman: TolimanOptics\n        A new `TolimanOptics` instance with the applied update.\n    \"\"\"\n    if index &lt; 0:\n        raise ValueError(\"`index` must be positive.\")\n\n    new_layers: list = self.to_optics_list()\n    length: int = len(new_layers)\n\n    if index &gt; length:\n        raise ValueError(\"`index` must be within the detector.\")\n\n    _: None = new_layers.pop(index)\n    dl_new_layers: dict = dl.utils.list_to_dictionary(new_layers)\n    return eqx.tree_at(lambda x: x.layers, self, dl_new_layers)\n</code></pre>"},{"location":"toliman/toliman/#toliman.toliman.TolimanDetector.to_optics_list","title":"<code>to_optics_list()</code>","text":"<p>Get the optical elements that make up the object as a list.</p> <p>Returns:</p> Name Type Description <code>optics</code> <code>list</code> <p>The optical layers in order in a list.</p> Source code in <code>toliman/toliman.py</code> <pre><code>def to_optics_list(self: object) -&gt; list:\n\"\"\"\n    Get the optical elements that make up the object as a list.\n\n    Returns\n    -------\n    optics: list\n        The optical layers in order in a list.\n    \"\"\"\n    return list(self.layers.values())\n</code></pre>"},{"location":"toliman/toliman/#toliman.toliman.TolimanDetector","title":"Toliman","text":""},{"location":"toliman/toliman/#toliman.toliman.TolimanDetector.__init__","title":"Toliman","text":""},{"location":"toliman/toliman/#toliman.toliman.TolimanDetector.append","title":"Toliman","text":""},{"location":"toliman/toliman/#toliman.toliman.TolimanDetector.insert","title":"Toliman","text":""},{"location":"toliman/toliman/#toliman.toliman.TolimanDetector.pop","title":"Toliman","text":""},{"location":"toliman/toliman/#toliman.toliman.TolimanDetector.remove","title":"Toliman","text":""},{"location":"toliman/toliman/#toliman.toliman.TolimanDetector.to_optics_list","title":"Toliman","text":""},{"location":"toliman/toliman/#toliman.toliman.TolimanOptics.__init__","title":"<code>__init__(simulate_polish=False, simulate_aberrations=True, operate_in_fresnel_mode=False, operate_in_static_mode=True, number_of_zernikes=int(os.environ['DEFAULT_NUMBER_OF_ZERNIKES']), pixels_in_pupil=int(os.environ['DEFAULT_PUPIL_NPIX']), pixels_on_detector=int(os.environ['DEFAULT_DETECTOR_NPIX']), path_to_mask=os.environ['DEFAULT_MASK_DIR'], path_to_filter='assets/filter.npy', path_to_polish='assets/polish.npy')</code>","text":"<p>Simulate the Toliman telescope.</p> <p>Parameters:</p> Name Type Description Default <code>simulate_polish</code> <code>bool</code> <p>True if a layer should be included simulating the polish on the secondary mirror.</p> <code>False</code> <code>simulate_aberrations</code> <code>bool</code> <p>True if the aberrations should be included.</p> <code>True</code> <code>operate_in_fresnel_mode</code> <code>bool</code> <p>True if the simulation should use Fresnel instead of Fourier optics.</p> <code>False</code> <code>operate_in_static_mode</code> <code>bool</code> <p>True if the pupil of the aperture should be modelled as static. This will improve performance so only change it if you want to learn a parameter of the aperture.</p> <code>True</code> <code>number_of_zernikes</code> <code>int</code> <p>The number of zernike polynomials that should be used to model the aberrations.</p> <code>int(os.environ['DEFAULT_NUMBER_OF_ZERNIKES'])</code> <code>pixels_in_pupil</code> <code>int</code> <p>The number of pixels in the pupil plane.</p> <code>int(os.environ['DEFAULT_PUPIL_NPIX'])</code> <code>pixels_on_detector</code> <code>int</code> <p>The number of pixels in the detector plane.</p> <code>int(os.environ['DEFAULT_DETECTOR_NPIX'])</code> <code>path_to_mask</code> <code>str</code> <p>The file location of a <code>.npy</code> file that contains an array representation o the mask.</p> <code>os.environ['DEFAULT_MASK_DIR']</code> <code>path_to_filter</code> <code>str</code> <p>The file location of a <code>.npy</code> file that contains an array representation og the filter.</p> <code>'assets/filter.npy'</code> <code>path_to_polish</code> <code>str</code> <p>The file location of a <code>.npy</code> file that contains an array representation of the secondary mirror polish.</p> <code>'assets/polish.npy'</code> Source code in <code>toliman/toliman.py</code> <pre><code>def __init__(\n    self: object,\n    simulate_polish: bool = False,\n    simulate_aberrations: bool = True,\n    operate_in_fresnel_mode: bool = False,\n    operate_in_static_mode: bool = True,\n    number_of_zernikes: int = int(os.environ[\"DEFAULT_NUMBER_OF_ZERNIKES\"]),\n    pixels_in_pupil: int = int(os.environ[\"DEFAULT_PUPIL_NPIX\"]),\n    pixels_on_detector: int = int(os.environ[\"DEFAULT_DETECTOR_NPIX\"]),\n    path_to_mask: str = os.environ[\"DEFAULT_MASK_DIR\"],\n    path_to_filter: str = \"assets/filter.npy\",\n    path_to_polish: str = \"assets/polish.npy\",\n) -&gt; object:\n\"\"\"\n    Simulate the Toliman telescope.\n\n    Parameters\n    ----------\n    simulate_polish: bool = True\n        True if a layer should be included simulating the polish\n        on the secondary mirror.\n    simulate_aberrations: bool = True\n        True if the aberrations should be included.\n    operate_in_fresnel_mode: bool = False\n        True if the simulation should use Fresnel instead of\n        Fourier optics.\n    operate_in_static_mode: bool = True\n        True if the pupil of the aperture should be modelled\n        as static. This will improve performance so only change\n        it if you want to learn a parameter of the aperture.\n    number_of_zernikes: int = DEFAULT_NUMBER_OF_ZERNIKES\n        The number of zernike polynomials that should be used\n        to model the aberrations.\n    pixels_in_pupil: int = DEFAULT_PUPIL_NPIX\n        The number of pixels in the pupil plane.\n    pixels_on_detector: int = DEFAULT_DETECTOR_NPIX\n        The number of pixels in the detector plane.\n    path_to_mask: str = \"assets/mask.npy\"\n        The file location of a `.npy` file that contains an\n        array representation o the mask.\n    path_to_filter: str = \"assets/filter.npy\"\n        The file location of a `.npy` file that contains an\n        array representation og the filter.\n    path_to_polish: str = \"assets/polish.npy\"\n        The file location of a `.npy` file that contains an\n        array representation of the secondary mirror polish.\n    \"\"\"\n    PRIMARY_APERTURE_DIAMETER: float = const.get_const_as_type(\"TOLIMAN_PRIMARY_APERTURE_DIAMETER\", float)\n    NUMBER_OF_STRUTS: int = const.get_const_as_type(\"TOLIMAN_NUMBER_OF_STRUTS\", int)\n    WIDTH_OF_STRUTS: float = const.get_const_as_type(\"TOLIMAN_WIDTH_OF_STRUTS\", float)\n    SECONDARY_MIRROR_DIAMETER: float = const.get_const_as_type(\"TOLIMAN_SECONDARY_MIRROR_DIAMETER\", float)\n    DETECTOR_PIXEL_SIZE: int = const.get_const_as_type(\"TOLIMAN_DETECTOR_PIXEL_SIZE\", float)\n\n    toliman_layers: list = [\n        dl.CreateWavefront(\n            pixels_in_pupil,\n            PRIMARY_APERTURE_DIAMETER,\n            wavefront_type=\"Angular\",\n        )\n    ]\n\n    # Adding the pupil\n    dyn_toliman_pupil: object = dl.CompoundAperture(\n        [\n            dl.UniformSpider(NUMBER_OF_STRUTS, WIDTH_OF_STRUTS),\n            dl.AnnularAperture(\n                PRIMARY_APERTURE_DIAMETER / 2.0,\n                SECONDARY_MIRROR_DIAMETER / 2.0,\n            ),\n        ]\n    )\n\n    if operate_in_static_mode:\n        static_toliman_pupil: object = dl.StaticAperture(\n            dyn_toliman_pupil,\n            npixels=pixels_in_pupil,\n            diameter=PRIMARY_APERTURE_DIAMETER,\n        )\n\n        toliman_layers.append(static_toliman_pupil)\n    else:\n        toliman_layers.append(dyn_toliman_pupil)\n\n    # Loading the mask.\n    try:\n        loaded_mask: float = np.load(path_to_mask)\n        loaded_shape: tuple = loaded_mask.shape\n        loaded_width: int = loaded_shape[0]\n\n        mask: float\n        if not loaded_width == pixels_in_pupil:\n            if loaded_width &lt; pixels_in_pupil:\n                raise NotImplementedError( \n                    \"The mask you have loaded had a higher resolution \" +\\\n                    \"than the pupil. A method of resolving this has not \" +\\\n                    \"yet been created. Either change the value of the \" +\\\n                    \"`DEFAULT_PUPIL_NPIX` constant or use a different mask.\"\n                )\n            if loaded_width % pixels_in_pupil == 0:\n                downsample_by: int = loaded_width // pixels_in_pupil\n                mask: float = math.downsample_square_grid(loaded_mask, downsample_by)\n            else:\n                raise ValueError(\n                    \"The mask you have loaded could not be downsampled \" +\\\n                    \"onto the pupil. The shape of the mask was \" +\\\n                    \"({%i, %i}). Either change the value of the \"\n                    \"environment variable `DEFAULT_PUPIL_NPIX` or use \" +\\\n                    \"a different mask.\".format(loaded_width, loaded_width)\n                )\n        else:\n            mask: float = loaded_mask\n\n        del loaded_mask\n        del loaded_shape\n        del loaded_width\n    except IOError as ioe:\n        raise ValueError(\n            \"The file address that of the mask did not exist. \" +\\\n            \"Make sure that you have a `.npy` representation of the \" +\\\n            \"phase mask available and have provided the correct file \" +\\\n            \"address to the constructor.\"\n        )\n\n    toliman_layers.append(dl.AddOPD(mask))\n\n    # Generating the Zernikes\n    # TODO: Make zernike_coefficients a function\n    if simulate_aberrations:\n        nolls: list = np.arange(2, number_of_zernikes + 2, dtype=int)\n        seed: object = jax.random.PRNGKey(0)\n        coeffs: list = 1e-08 * jax.random.normal(seed, (number_of_zernikes,))\n\n        toliman_aberrations: object = dl.StaticAberratedAperture(\n            dl.AberratedAperture(\n                noll_inds=nolls,\n                coefficients=coeffs,\n                aperture=dl.CircularAperture(\n                    PRIMARY_APERTURE_DIAMETER / 2.0\n                ),\n            ),\n            npixels=pixels_in_pupil,\n            diameter=PRIMARY_APERTURE_DIAMETER,\n        )\n\n        toliman_layers.append(toliman_aberrations)\n\n    toliman_layers.append(dl.NormaliseWavefront())\n\n    if simulate_polish:\n        raise NotImplementedError(\n            \"You have requested that the mirror polish be simulated \" +\\\n            \"this has not yet been implemented although it is planned \" +\\\n            \"in an upcoming release.\"\n        )\n\n    # Adding the propagator\n    toliman_body: object\n    if not operate_in_fresnel_mode:\n        toliman_body: object = dl.AngularMFT(\n            pixels_on_detector, DETECTOR_PIXEL_SIZE\n        )\n    else:\n        raise NotImplementedError(\n            \"You have request operation in Fresenl mode. This has \" +\\\n            \"not currently been implemented. Once implemented it \" +\\\n            \"is not recommended that you use the feature as it is \" +\\\n            \"very slow and the zernike terms should be sufficient for \" +\\\n            \"most purposes.\"\n        )\n\n    toliman_layers.append(toliman_body)\n\n    # Renormalising the flux.\n    toliman_layers.append(dl.NormaliseWavefront())\n\n    super().__init__(layers=toliman_layers)\n</code></pre>"},{"location":"toliman/toliman/#toliman.toliman.TolimanOptics.append","title":"<code>append(optic)</code>","text":"<p>Place a new optic at the end of the optical system.</p> <p>Parameters:</p> Name Type Description Default <code>optic</code> <code>object</code> <p>The optic to include. It must be a subclass of the <code>dLux.OpticalLayer</code>.</p> required <p>Returns:</p> Name Type Description <code>optics</code> <code>object</code> <p>The new optical system.</p> Source code in <code>toliman/toliman.py</code> <pre><code>def append(self: object, optic: object) -&gt; object:\n\"\"\"\n    Place a new optic at the end of the optical system.\n\n    Parameters\n    ----------\n    optic: object\n        The optic to include. It must be a subclass of the\n        `dLux.OpticalLayer`.\n\n    Returns\n    -------\n    optics: object\n        The new optical system.\n    \"\"\"\n    correct_type: bool = False\n    if isinstance(optic, dl.optics.OpticalLayer):\n        correct_type: bool = True\n    elif isinstance(optic, dl.apertures.ApertureLayer):\n        correct_type: bool = True\n\n    if not correct_type:\n        raise ValueError(\"Inserted optics must be optical layers.\")\n\n    new_layers: list = self.to_optics_list()\n    _: None = new_layers.append(optic)\n    dl_new_layers: dict = dl.utils.list_to_dictionary(new_layers)\n    return eqx.tree_at(lambda x: x.layers, self, dl_new_layers)\n</code></pre>"},{"location":"toliman/toliman/#toliman.toliman.TolimanOptics.insert","title":"<code>insert(optic, index)</code>","text":"<p>Add an additional layer to the optical system.</p> <p>Parameters:</p> Name Type Description Default <code>optic</code> <code>object</code> <p>A <code>dLux.OpticalLayer</code> to include in the model.</p> required <code>index</code> <code>int</code> <p>Where in the list of layers to add optic.</p> required <p>Returns:</p> Name Type Description <code>toliman</code> <code>TolimanOptics</code> <p>A new <code>TolimanOptics</code> instance with the applied update.</p> Source code in <code>toliman/toliman.py</code> <pre><code>def insert(self: object, optic: object, index: int) -&gt; object:\n\"\"\"\n    Add an additional layer to the optical system.\n\n    Parameters\n    ----------\n    optic: object\n        A `dLux.OpticalLayer` to include in the model.\n    index: int\n        Where in the list of layers to add optic.\n\n    Returns\n    -------\n    toliman: TolimanOptics\n        A new `TolimanOptics` instance with the applied update.\n    \"\"\"\n    correct_type: bool = False\n    if isinstance(optic, dl.optics.OpticalLayer):\n        correct_type: bool = True\n    elif isinstance(optic, dl.apertures.ApertureLayer):\n        correct_type: bool = True\n\n    if not correct_type:\n        raise ValueError(\"Inserted optics must be optical layers.\")\n\n    if index &lt; 0:\n        raise ValueError(\"`index` must be positive.\")\n\n    new_layers: list = self.to_optics_list()\n    _: None = new_layers.insert(index, optic)\n    dl_new_layers: dict = dl.utils.list_to_dictionary(new_layers)\n    return eqx.tree_at(lambda x: x.layers, self, dl_new_layers)\n</code></pre>"},{"location":"toliman/toliman/#toliman.toliman.TolimanOptics.pop","title":"<code>pop()</code>","text":"<p>Remove the last element in the optical system.</p> <p>Please note that this differs from the <code>.pop</code> method of the <code>list</code> class  because it does not return the popped element.</p> <p>Returns:</p> Name Type Description <code>optics</code> <code>object</code> <p>The optical system with the layer removed.</p> Source code in <code>toliman/toliman.py</code> <pre><code>def pop(self: object) -&gt; object:\n\"\"\"\n    Remove the last element in the optical system.\n\n    Please note that this differs from the `.pop` method of\n    the `list` class  because it does not return the popped element.\n\n    Returns\n    -------\n    optics: object\n        The optical system with the layer removed.\n    \"\"\"\n    new_layers: list = self.to_optics_list()\n    _: object = new_layers.pop()\n    dl_new_layers: dict = dl.utils.list_to_dictionary(new_layers)\n    return eqx.tree_at(lambda x: x.layers, self, dl_new_layers)\n</code></pre>"},{"location":"toliman/toliman/#toliman.toliman.TolimanOptics.remove","title":"<code>remove(index)</code>","text":"<p>Take a layer from the optical system.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Where in the list of layers to remove an optic.</p> required <p>Returns:</p> Name Type Description <code>toliman</code> <code>TolimanOptics</code> <p>A new <code>TolimanOptics</code> instance with the applied update.</p> Source code in <code>toliman/toliman.py</code> <pre><code>def remove(self: object, index: int) -&gt; object:\n\"\"\"\n    Take a layer from the optical system.\n\n    Parameters\n    ----------\n    index: int\n        Where in the list of layers to remove an optic.\n\n    Returns\n    -------\n    toliman: TolimanOptics\n        A new `TolimanOptics` instance with the applied update.\n    \"\"\"\n    if index &lt; 0:\n        raise ValueError(\"`index` must be positive.\")\n\n    new_layers: list = self.to_optics_list()\n    length: int = len(new_layers)\n\n    if index &gt; length:\n        raise ValueError(\"`index` must be within the optical system.\")\n\n    _: None = new_layers.pop(index)\n    dl_new_layers: dict = dl.utils.list_to_dictionary(new_layers)\n    return eqx.tree_at(lambda x: x.layers, self, dl_new_layers)\n</code></pre>"},{"location":"toliman/toliman/#toliman.toliman.TolimanOptics.to_optics_list","title":"<code>to_optics_list()</code>","text":"<p>Get the optical elements that make up the object as a list.</p> <p>Returns:</p> Name Type Description <code>optics</code> <code>list</code> <p>The optical layers in order in a list.</p> Source code in <code>toliman/toliman.py</code> <pre><code>def to_optics_list(self: object) -&gt; list:\n\"\"\"\n    Get the optical elements that make up the object as a list.\n\n    Returns\n    -------\n    optics: list\n        The optical layers in order in a list.\n    \"\"\"\n    return list(self.layers.values())\n</code></pre>"},{"location":"toliman/toliman/#toliman.toliman.TolimanOptics","title":"Toliman","text":""},{"location":"toliman/toliman/#toliman.toliman.TolimanOptics.__init__","title":"Toliman","text":""},{"location":"toliman/toliman/#toliman.toliman.TolimanOptics.append","title":"Toliman","text":""},{"location":"toliman/toliman/#toliman.toliman.TolimanOptics.insert","title":"Toliman","text":""},{"location":"toliman/toliman/#toliman.toliman.TolimanOptics.pop","title":"Toliman","text":""},{"location":"toliman/toliman/#toliman.toliman.TolimanOptics.remove","title":"Toliman","text":""},{"location":"toliman/toliman/#toliman.toliman.TolimanOptics.to_optics_list","title":"Toliman","text":""},{"location":"toliman/toliman/#toliman.toliman.AlphaCentauri.__init__","title":"<code>__init__(spectrum=None)</code>","text":"<p>Simulate Alpha Centauri.</p> <p>Parameters:</p> Name Type Description Default <code>spectrum</code> <code>float</code> <p>A <code>dl.Spectrum</code> if the default is not to be used. Recall that the convinience method <code>_simulate_alpha_cen_spectrum</code> can be used to simulate the spectrum.</p> <code>None</code> Source code in <code>toliman/toliman.py</code> <pre><code>def __init__(self: object, spectrum: float = None) -&gt; object:\n\"\"\"\n    Simulate Alpha Centauri.\n\n    Parameters\n    ----------\n    spectrum: float = None\n        A `dl.Spectrum` if the default is not to be used. Recall\n        that the convinience method `_simulate_alpha_cen_spectrum`\n        can be used to simulate the spectrum.\n    \"\"\"\n    SPECTRUM_DIR: str = const.get_const_as_type(\"SPECTRUM_DIR\", str) \n\n    if not spectrum:\n        _spectrum: float = io.read_csv_to_jax_array(SPECTRUM_DIR) \n\n        alpha_cen_a_waves: float = _spectrum[:, 0]\n        alpha_cen_b_waves: float = _spectrum[:, 2]\n        alpha_cen_a_flux: float = _spectrum[:, 1]\n        alpha_cen_b_flux: float = _spectrum[:, 3]\n\n        alpha_cen_waves: float = np.stack([alpha_cen_a_waves, alpha_cen_b_waves])\n        alpha_cen_flux: float = np.stack([alpha_cen_a_flux, alpha_cen_b_flux])\n\n        spectrum: float = dl.CombinedSpectrum(\n            wavelengths=alpha_cen_waves, weights=alpha_cen_flux\n        )\n\n    ALPHA_CENTAURI_POSITION: float = const.get_const_as_type(\"ALPHA_CENTAURI_POSITION\", np.array)\n    ALPHA_CENTAURI_MEAN_FLUX: float = const.get_const_as_type(\"ALPHA_CENTAURI_MEAN_FLUX\", float)\n    ALPHA_CENTAURI_CONTRAST: float = const.get_const_as_type(\"ALPHA_CENTAURI_CONTRAST\", float)\n    ALPHA_CENTAURI_SEPARATION: float = const.get_const_as_type(\"ALPHA_CENTAURI_SEPARATION\", float)\n    ALPHA_CENTAURI_POSITION_ANGLE: float = const.get_const_as_type(\"ALPHA_CENTAURI_POSITION_ANGLE\", float)\n\n    super().__init__(\n        position=ALPHA_CENTAURI_POSITION,\n        flux=ALPHA_CENTAURI_MEAN_FLUX,\n        contrast=ALPHA_CENTAURI_CONTRAST,\n        separation=ALPHA_CENTAURI_SEPARATION,\n        position_angle=ALPHA_CENTAURI_POSITION_ANGLE,\n        spectrum=spectrum,\n    )\n</code></pre>"},{"location":"toliman/toliman/#toliman.toliman.AlphaCentauri","title":"Toliman","text":""},{"location":"toliman/toliman/#toliman.toliman.AlphaCentauri.__init__","title":"Toliman","text":""},{"location":"toliman/toliman/#toliman.toliman.Background.__init__","title":"<code>__init__(number_of_bg_stars=None, spectrum=None)</code>","text":"<p>Simulate background stars.</p> <p>Parameters:</p> Name Type Description Default <code>number_of_bg_stars</code> <code>int</code> <p>How many background stars should be simulated.</p> <code>None</code> <code>spectrum</code> <code>object</code> <p>A <code>dl.Spectrum</code> if the default spectrum is not to be used.</p> <code>None</code> Source code in <code>toliman/toliman.py</code> <pre><code>def __init__(\n    self: object, number_of_bg_stars: int = None, spectrum: object = None\n) -&gt; object:\n\"\"\"\n    Simulate background stars.\n\n    Parameters\n    ----------\n    number_of_bg_stars: int = None\n        How many background stars should be simulated.\n    spectrum: object = None\n        A `dl.Spectrum` if the default spectrum is not to be used.\n    \"\"\"\n    FILTER_MIN_WAVELENGTH: float = const.get_const_as_type(\"FILTER_MIN_WAVELENGTH\", float)\n    FILTER_MAX_WAVELENGTH: float = const.get_const_as_type(\"FILTER_MAX_WAVELENGTH\", float)\n    BG_DEF_SPEC_RES: int = const.get_const_as_type(\"BACKGROUND_STAR_SPEC_RES\", int)\n    BACKGROUND_DIR: str = const.get_const_as_type(\"BACKGROUND_DIR\", str) \n\n    if not spectrum:\n        spectrum: object = dl.ArraySpectrum(\n            wavelengths=np.linspace(\n                FILTER_MIN_WAVELENGTH, FILTER_MAX_WAVELENGTH, BG_DEF_SPEC_RES\n            ),\n            weights=np.ones((BG_DEF_SPEC_RES,), dtype=float),\n        )\n\n    # TODO: Better error handling if BACKGROUND_DIR is not valid\n    _background: float = io.read_csv_to_jax_array(BACKGROUND_DIR)\n\n    if number_of_bg_stars:\n        select_by: int = _background.shape[0] // number_of_bg_stars\n        _background: float = _background[::select_by, :]\n\n    position: float = np.pi / 180 * _background[:, (0, 1)]\n    flux: float = 1e5 * _background[:, 2]\n\n    super().__init__(position=position, flux=flux, spectrum=spectrum)\n</code></pre>"},{"location":"toliman/toliman/#toliman.toliman.Background","title":"Toliman","text":""},{"location":"toliman/toliman/#toliman.toliman.Background.__init__","title":"Toliman","text":""},{"location":"toliman/build/background/","title":"Background","text":""},{"location":"toliman/build/background/#overview","title":"Overview","text":"<p>Due to the nature of the PSF background stars have a good chance of  affecting the science signal. In particular we are interested in the  sidelobes although we haven't decided how to deal with these yet. This file porvides an API for generating a typical sample of background  stars using the Gaia database. </p>"},{"location":"toliman/build/background/#api","title":"API","text":"<code>load_background_stars</code> <p>Retrieve a sample of backgound stars from the Gaia database.</p> <p>Selects the top 12000 stars and contains only the entries that  contain a measured flux. A word of caution is don't work near to zero as some of the ra/dec may wrap around to 360, which  causes things to break when recentering. This is not checked  programmatically, but is a painful experience.</p> <p>Parameters:</p> Name Type Description Default <code>ra</code> <code>float</code> <p>The right ascension of section of sky to survey.</p> required <code>dec</code> <code>float</code> <p>The declination of the section of sky to survey.</p> required <code>rad</code> <code>float</code> <p>The radius of the conical region to survey.</p> required <p>Returns:</p> Name Type Description <code>background</code> <code>float</code> <p>A sample of positions (ra, dec), and fluxes of a preselected  background region of sky. The convention is RA along 0, DEC  along 1 and FLUX along 2.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; load_background_stars(3.0, 3.0, 2.0)\n</code></pre> Source code in <code>toliman/build/background.py</code> <pre><code>def load_background_stars(ra: float, dec: float, rad: float) -&gt; float:\n\"\"\"\n    Retrieve a sample of backgound stars from the Gaia database.\n\n    Selects the top 12000 stars and contains only the entries that \n    contain a measured flux. A word of caution is don't work near\n    to zero as some of the ra/dec may wrap around to 360, which \n    causes things to break when recentering. This is not checked \n    programmatically, but is a painful experience.\n\n    Parameters\n    ----------\n    ra: float, deg \n        The right ascension of section of sky to survey.\n    dec: float, deg \n        The declination of the section of sky to survey.\n    rad: float, deg \n        The radius of the conical region to survey.\n\n    Returns\n    -------\n    background: float \n        A sample of positions (ra, dec), and fluxes of a preselected \n        background region of sky. The convention is RA along 0, DEC \n        along 1 and FLUX along 2.\n\n    Examples\n    --------\n    ```python \n    &gt;&gt;&gt; load_background_stars(3.0, 3.0, 2.0)\n    ```\n    \"\"\"\n    if ra &lt;= rad:\n        warnings.warn(\"`ra &lt;= rad`. Coordinate wrapping may occur.\")\n\n    from astroquery.gaia import Gaia\n\n    bg_stars: object = Gaia.launch_job(CONICAL_QUERY.format(ra, dec, rad))\n\n    return np.array([\n            np.array(bg_stars.results[\"ra\"]) - ra,\n            np.array(bg_stars.results[\"dec\"]) - dec,\n            np.array(bg_stars.results[\"flux\"]),\n        ], dtype = float)\n</code></pre> <code>window_background_stars</code> <p>Get a square array of background stars.</p> <p>Parameters:</p> Name Type Description Default <code>background</code> <code>float</code> <p>Coordinates (ra, dec), and fluxes of a set of stars. The conventions is [RA, DEC, FLUX] along the leading axis.</p> required <code>width</code> <code>float</code> <p>The width of the square region to cut.</p> required <p>Returns:</p> Name Type Description <code>background_in_square</code> <code>float, [deg, deg, W</code> <p>The coordinates (ra, dec) and fluxes of a set of background  stars within a square.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; bgstars: float = load_background_stars(0.0, 0.0, 2.0)\n&gt;&gt;&gt; windowed_bgstars: float = window_bg_stars(bgstars, 1.0)\n</code></pre> Source code in <code>toliman/build/background.py</code> <pre><code>def window_background_stars(background: float, width: float) -&gt; float:\n\"\"\"\n    Get a square array of background stars.\n\n    Parameters\n    ----------\n    background: float, [deg, deg, W/m/m]\n        Coordinates (ra, dec), and fluxes of a set of stars. The\n        conventions is [RA, DEC, FLUX] along the leading axis.\n    width: float, deg\n        The width of the square region to cut.\n\n    Returns\n    -------\n    background_in_square: float, [deg, deg, W/m/m]\n        The coordinates (ra, dec) and fluxes of a set of background \n        stars within a square.\n\n    Examples\n    --------\n    &gt;&gt;&gt; bgstars: float = load_background_stars(0.0, 0.0, 2.0)\n    &gt;&gt;&gt; windowed_bgstars: float = window_bg_stars(bgstars, 1.0)\n    \"\"\"\n    in_width: float = np.abs(background[(0, 1), :]) &lt; width\n    logical_and: callable = lambda x: np.logical_and(x[0], x[1])\n    in_range: float = np.apply_along_axis(logical_and, 0, in_width)\n    return background[:, in_range]\n</code></pre> <code>flux_relative_to_alpha_cen</code> <p>Convert the flux into relative units.</p> <p>Parameters:</p> Name Type Description Default <code>background</code> <code>float</code> <p>The coordinates (ra, dec) and fluxes of a sample of background  stars. The convention is [RA, DEC, FLUX] along the leading  (zeroth) axis.</p> required <code>save_background_stars</code> <p>Save the background stars to a prespecified location.</p> <p>In order to simplify the interface with programs written using  <code>toliman</code> all resource files are stored in a specfic directory <code>TOLIMAN_HOME</code>.</p> <p>Parameters:</p> Name Type Description Default <code>background</code> <code>float</code> <p>The coordinates (ra, dec) and fluxes of a sample of background  stars. The indexing convention is [RA, DEC, FLUX] along the  leading axis.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; bgstars: float = load_background_stars(0.0, 0.0, 2.0)\n&gt;&gt;&gt; win_stars: float = window_background_stars(bgstars, 1.0)\n&gt;&gt;&gt; rel_stars: float = flux_relative_to_alpha_cen(win_stars)\n&gt;&gt;&gt; save_background_stars(rel_stars)\n</code></pre> Source code in <code>toliman/build/background.py</code> <pre><code>def save_background_stars(background: float, root: str) -&gt; None:\n\"\"\"\n    Save the background stars to a prespecified location.\n\n    In order to simplify the interface with programs written using \n    `toliman` all resource files are stored in a specfic directory\n    `TOLIMAN_HOME`.\n\n    Parameters\n    ----------\n    background: float, [deg, deg, W/m/m]\n        The coordinates (ra, dec) and fluxes of a sample of background \n        stars. The indexing convention is [RA, DEC, FLUX] along the \n        leading axis.\n\n    Examples\n    --------\n    &gt;&gt;&gt; bgstars: float = load_background_stars(0.0, 0.0, 2.0)\n    &gt;&gt;&gt; win_stars: float = window_background_stars(bgstars, 1.0)\n    &gt;&gt;&gt; rel_stars: float = flux_relative_to_alpha_cen(win_stars)\n    &gt;&gt;&gt; save_background_stars(rel_stars)\n    \"\"\"\n    if background.shape[0] != 3:\n        raise ValueError(\"Invalid background stars.\")\n    if not os.path.isdir(root):\n        os.mkdir(root)\n    with open(paths.concat([root, \"background.csv\"]), \"w\") as sheet:\n        sheet.write(\"ra,dec,rel_flux\\n\")\n        for row in np.arange(background[RA].size):\n            sheet.write(\"{},\".format(background[RA][row]))\n            sheet.write(\"{},\".format(background[DEC][row]))\n            sheet.write(\"{}\\n\".format(background[FLUX][row]))\n</code></pre>"},{"location":"toliman/build/background/#toliman.build.background.load_background_stars","title":"Background","text":""},{"location":"toliman/build/background/#toliman.build.background.window_background_stars","title":"Background","text":""},{"location":"toliman/build/background/#toliman.build.background.flux_relative_to_alpha_cen--returns","title":"Returns","text":"<p>background: float, [deg, deg, W/m/m]     The coordinates (ra, dec) and fluxes of the sample. The same     indexing convention is maintained but the units of the flux      are altered.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; bgstars: float = load_background_stars(0.0, 0.0, 2.0)\n&gt;&gt;&gt; win_stars: float = window_background_stars(bgstars, 1.0)\n&gt;&gt;&gt; rel_stars: float = flux_relative_to_alpha_cen(win_stars)\n</code></pre> Source code in <code>toliman/build/background.py</code> <pre><code>def flux_relative_to_alpha_cen(background: float) -&gt; float:\n\"\"\"\n    Convert the flux into relative units.\n\n    Parameters\n    ----------\n    background: float, [deg, deg, W/m/m]\n        The coordinates (ra, dec) and fluxes of a sample of background \n        stars. The convention is [RA, DEC, FLUX] along the leading \n        (zeroth) axis.\n\n    Returns \n    -------\n    background: float, [deg, deg, W/m/m]\n        The coordinates (ra, dec) and fluxes of the sample. The same\n        indexing convention is maintained but the units of the flux \n        are altered.\n\n    Examples\n    --------\n    &gt;&gt;&gt; bgstars: float = load_background_stars(0.0, 0.0, 2.0)\n    &gt;&gt;&gt; win_stars: float = window_background_stars(bgstars, 1.0)\n    &gt;&gt;&gt; rel_stars: float = flux_relative_to_alpha_cen(win_stars)\n    \"\"\"\n    return np.array([\n            background[RA], \n            background[DEC],\n            background[FLUX] / ALPHA_CEN_FLUX\n        ], dtype = float)\n</code></pre>"},{"location":"toliman/build/background/#toliman.build.background.flux_relative_to_alpha_cen","title":"Background","text":""},{"location":"toliman/build/background/#toliman.build.background.flux_relative_to_alpha_cen--returns","title":"Returns","text":""},{"location":"toliman/build/background/#toliman.build.background.save_background_stars","title":"Background","text":""},{"location":"toliman/build/build/","title":"Build","text":""},{"location":"toliman/build/build/#overview","title":"Overview","text":"<p>The build module is divided into a porcelain API and a plumbing API. The  procelain API is only two commands and will completely setup the toliman  data files. The plumbing commands on the other hand can be used to controll each data file individually, so are more useful for updatting the model  than the porcelain commands. The terminology porcelain and plumbing is  stolen from <code>git</code>.</p> <p>This is the simplest (porcelain) interface for setting up the data files  associated with the forwards model. It consists of just two commands  <code>is_toliman_installed</code> and <code>install_toliman</code>. The first will check for  an existing installation and the second will download and save the  data files from the internet. Depending on the speed of your connection  this can take a considerable amount of time because a lot of the files  are megabytes in size. </p> <p>There is some nuance to using this code. Firstly, when running in a  default setting <code>install_toliman</code> will check at the plumbing level  for installed files and only install no installation is detected. To  override this behaviour use the <code>force</code> argument.</p>"},{"location":"toliman/build/build/#api","title":"API","text":"<code>is_toliman_installed</code> <p>Checks if all the assets files for toliman are installed.</p> <p>Parameters:</p> Name Type Description Default <code>root</code> <code>str</code> <p>The directory to search in. This should be TOLIMAN_HOME  but I have enabled other options if multiple installations  exist.</p> <code>TOLIMAN_HOME</code> <p>Returns:</p> Name Type Description <code>installed</code> <code>bool</code> <p>True if all the components are installed, else False.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import toliman.build as build\n&gt;&gt;&gt; import toliman.build.mask as mask\n&gt;&gt;&gt; import toliman.build.phoenix as phoenix\n&gt;&gt;&gt; import toliman.build.background as bg\n&gt;&gt;&gt; import shutil \n&gt;&gt;&gt; import os\n&gt;&gt;&gt; if os.path.isdir(\"tmp\"):\n...     shutil.rmtree(\"tmp\")\n&gt;&gt;&gt; os.mkdir(\"tmp\")\n&gt;&gt;&gt; mask.install_mask(\"tmp\")\n&gt;&gt;&gt; mask.is_mask_installed(\"tmp\")\n::: True\n&gt;&gt;&gt; phoenix.is_phoenix_installed(\"tmp\")\n::: False\n&gt;&gt;&gt; bg.is_background_installed(\"tmp\")\n::: False\n&gt;&gt;&gt; build.is_toliman_installed(\"tmp\")\n::: False\n&gt;&gt;&gt; phoenix.install_phoenix(\"tmp\")\n&gt;&gt;&gt; bg.install_background_stars(\"tmp\")\n&gt;&gt;&gt; build.is_toliman_installed(\"tmp\")\n::: True\n</code></pre> Source code in <code>toliman/build/build.py</code> <pre><code>def is_toliman_installed(root: str = TOLIMAN_HOME) -&gt; bool:\n\"\"\"\n    Checks if all the assets files for toliman are installed.\n\n    Parameters\n    ----------\n    root: str = TOLIMAN_HOME\n        The directory to search in. This should be TOLIMAN_HOME \n        but I have enabled other options if multiple installations \n        exist.\n\n    Returns\n    -------\n    installed: bool\n        True if all the components are installed, else False.\n\n    Examples\n    --------\n    ```python\n    &gt;&gt;&gt; import toliman.build as build\n    &gt;&gt;&gt; import toliman.build.mask as mask\n    &gt;&gt;&gt; import toliman.build.phoenix as phoenix\n    &gt;&gt;&gt; import toliman.build.background as bg\n    &gt;&gt;&gt; import shutil \n    &gt;&gt;&gt; import os\n    &gt;&gt;&gt; if os.path.isdir(\"tmp\"):\n    ...     shutil.rmtree(\"tmp\")\n    &gt;&gt;&gt; os.mkdir(\"tmp\")\n    &gt;&gt;&gt; mask.install_mask(\"tmp\")\n    &gt;&gt;&gt; mask.is_mask_installed(\"tmp\")\n    ::: True\n    &gt;&gt;&gt; phoenix.is_phoenix_installed(\"tmp\")\n    ::: False\n    &gt;&gt;&gt; bg.is_background_installed(\"tmp\")\n    ::: False\n    &gt;&gt;&gt; build.is_toliman_installed(\"tmp\")\n    ::: False\n    &gt;&gt;&gt; phoenix.install_phoenix(\"tmp\")\n    &gt;&gt;&gt; bg.install_background_stars(\"tmp\")\n    &gt;&gt;&gt; build.is_toliman_installed(\"tmp\")\n    ::: True\n    ```\n    \"\"\"\n    component_installations: list = [\n        phoenix.is_phoenix_installed(),\n        mask.is_mask_installed(),\n        bg.are_background_stars_installed(),\n    ]\n\n    return all(component_installations)\n</code></pre> <code>install_toliman</code> <p>Install all the resource files for toliman.</p> <p>Parameters:</p> Name Type Description Default <code>number_of_wavelengths</code> <code>int</code> <p>How many wavelengths should be saved in the spectra  generated using <code>phoenix</code> models?</p> required <code>root</code> <code>str</code> <p>The directory to search in. This should be TOLIMAN_HOME  but I have enabled other options if multiple installations  exist.</p> <code>TOLIMAN_HOME</code> <code>force</code> <code>bool</code> <p>If True then any existing installation will be deleted.  Otherwise existsing files will be skipped if a partial  implementation exists.</p> <code>False</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import toliman.build as build\n&gt;&gt;&gt; build.get_toliman_home()\n::: .assets\n&gt;&gt;&gt; build.is_toliman_installed()\n::: False\n&gt;&gt;&gt; build.install_toliman()\n&gt;&gt;&gt; build.is_toliman_installed()\n::: True\n</code></pre> Source code in <code>toliman/build/build.py</code> <pre><code>def install_toliman(\n        number_of_wavelengths: int, \n        root: str = TOLIMAN_HOME, /, \n        force: bool = False\n    ) -&gt; None:\n\"\"\"\n    Install all the resource files for toliman.\n\n    Parameters\n    ----------\n    number_of_wavelengths: int\n        How many wavelengths should be saved in the spectra \n        generated using `phoenix` models?\n    root: str = TOLIMAN_HOME\n        The directory to search in. This should be TOLIMAN_HOME \n        but I have enabled other options if multiple installations \n        exist.\n    force: bool = False\n        If True then any existing installation will be deleted. \n        Otherwise existsing files will be skipped if a partial \n        implementation exists.\n\n    Examples\n    --------\n    ```python\n    &gt;&gt;&gt; import toliman.build as build\n    &gt;&gt;&gt; build.get_toliman_home()\n    ::: .assets\n    &gt;&gt;&gt; build.is_toliman_installed()\n    ::: False\n    &gt;&gt;&gt; build.install_toliman()\n    &gt;&gt;&gt; build.is_toliman_installed()\n    ::: True\n    ```\n    \"\"\"\n    print(color_str_as_code(\"Building `toliman`!\"))\n\n    if not phoenix.is_phoenix_installed(root) or force:\n        print(\"Installing phoenix...\")\n        phoenix.install_phoenix(root, full = True)\n        print(\"Done!\")\n\n    if not phoenix.is_spectra_installed(root) or force: \n        print(\"Installing spectra...\")\n        phoenix.install_spectra(root, number_of_wavelengths)\n        print(\"Done!\")\n\n    if not bg.are_background_stars_installed(root) or force:\n        print(\"Installing background stars...\")\n        bg.install_background_stars(root)\n        print(\"Done!\")\n\n    if not mask.is_mask_installed(root) or force:\n        print(\"Installing mask...\")\n        mask.install_mask(root)\n        print(\"Done!\")\n\n    print(color_str_as_code(\"`toliman` built!\"))\n</code></pre>"},{"location":"toliman/build/build/#toliman.build.is_toliman_installed","title":"Build","text":""},{"location":"toliman/build/build/#toliman.build.install_toliman","title":"Build","text":""},{"location":"toliman/build/https/","title":"Https","text":""},{"location":"toliman/build/https/#overview","title":"Overview","text":"<p>Unfortunately, the toliman forwards model is not completely self contained, since the datafiles need to be shared and it is inefficient to do so using  <code>git</code>. We automated this process so that it was easy for the user, writing  code to download the files from the interent. Unfortunately some of the  files are very large so it takes a long time to download them (slower or  faster depending on your connection). </p> <p>A focus of the early forwards model development was ensuring that it was  rigorously tested so that later users could more easily extend and debug.  However, unit tests have to be faster and completely downloading all of the dependencies meant that the tests would take hours to run, rendering  them useless. As a result, for testing purposes this submodule also  provides functionality to download a single byte instead of an entire  file. This is mostly used for testing.</p> <p>Note</p> <p>Good tests are repeatable i.e. deterministic. While we speant some time making sure that the tests were fast, the internet is the interent and  connections can fail. This means that the tests are not completely  deterministic, but, if your connection is good, then they are effectively deterministic.</p>"},{"location":"toliman/build/https/#api","title":"API","text":"<code>get_https_stream</code> <p>Load a website as an iterable.</p> <p>This function is used to lazily load a website. Although the total  runtime may be slower it allows for much faster tests by permitting only a small chunk of the website to be downloaded at a time. <code>get_https_stream</code> raises a <code>ValueError</code> upon a failure.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The website to visit.</p> required <p>Returns:</p> Name Type Description <code>stream</code> <code>object</code> <p>An iterable representing the website data.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; get_https_stream(\"https:/im/not/real.com\")\n::: ValueError\n</code></pre> Source code in <code>toliman/build/https.py</code> <pre><code>def get_https_stream(url: str) -&gt; object:\n\"\"\"\n    Load a website as an iterable.\n\n    This function is used to lazily load a website. Although the total \n    runtime may be slower it allows for much faster tests by permitting\n    only a small chunk of the website to be downloaded at a time.\n    `get_https_stream` raises a `ValueError` upon a failure.\n\n    Parameters\n    ----------\n    url: str \n        The website to visit.\n\n    Returns\n    -------\n    stream: object \n        An iterable representing the website data.\n\n    Examples\n    --------\n    &gt;&gt;&gt; get_https_stream(\"https:/im/not/real.com\")\n    ::: ValueError\n    \"\"\"\n    response: iter = requests.get(url, stream=True)\n\n    if not response.status_code == 200:\n        raise ValueError\n\n    return response\n</code></pre> <code>download_file_from_https</code> <p>Download a file from the internet.</p> <p>This will save a file on the internet to <code>path</code>. It is assumed  that <code>path</code> does not currently exist. If it does a warning is  given and the download is skipped.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The location to save the file to.</p> required <code>url</code> <code>object</code> <p>The address of the information on the internet.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; import os\n&gt;&gt;&gt; os.mkdir(\"tmp\")\n&gt;&gt;&gt; with open(\"tmp/text.txt\", \"w\") as file:\n&gt;&gt;&gt;     pass\n&gt;&gt;&gt; download_file_from_https(\"tmp/text.txt\", \"github.com\")\n::: \"`path` exists. Skipping download\"\n&gt;&gt;&gt; download_file_from_https(\"tmp/github.txt\", \"github.com\")\n&gt;&gt;&gt; os.path.isfile(\"tmp/github.txt\")\n::: True\n</code></pre> Source code in <code>toliman/build/https.py</code> <pre><code>def download_file_from_https(path: str, url: object) -&gt; None:\n\"\"\"\n    Download a file from the internet.\n\n    This will save a file on the internet to `path`. It is assumed \n    that `path` does not currently exist. If it does a warning is \n    given and the download is skipped.\n\n    Parameters\n    ----------\n    path: str\n        The location to save the file to.\n    url: str\n        The address of the information on the internet.\n\n    Examples\n    --------\n    &gt;&gt;&gt; import os\n    &gt;&gt;&gt; os.mkdir(\"tmp\")\n    &gt;&gt;&gt; with open(\"tmp/text.txt\", \"w\") as file:\n    &gt;&gt;&gt;     pass\n    &gt;&gt;&gt; download_file_from_https(\"tmp/text.txt\", \"github.com\")\n    ::: \"`path` exists. Skipping download\"\n    &gt;&gt;&gt; download_file_from_https(\"tmp/github.txt\", \"github.com\")\n    &gt;&gt;&gt; os.path.isfile(\"tmp/github.txt\")\n    ::: True\n    \"\"\"\n    if os.path.isfile(path):\n        warnings.warn(\"`path` exists. Skipping download.\")\n        return None\n\n    response: iter = get_https_stream(url).iter_content(BYTE)\n\n    with open(path, \"wb\") as file:\n        for data in response:\n            file.write(data)\n</code></pre> <code>download_byte_from_https</code> <p>Download a single byte of a file from the internet.</p> <p>This will save the first byte of a file on the internet to <code>path</code>. If <code>path</code> already points to a file a warning is printed and the  download is skipped.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The location to save the file to.</p> required <code>url</code> <code>object</code> <p>The address of the information on the internet.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; import os\n&gt;&gt;&gt; os.mkdir(\"tmp\")\n&gt;&gt;&gt; with open(\"tmp/text.txt\", \"w\") as file:\n&gt;&gt;&gt;     pass\n&gt;&gt;&gt; download_byte_from_https(\"tmp/text.txt\", \"github.com\")\n::: \"`path` exists. Skipping download\"\n&gt;&gt;&gt; download_byte_from_https(\"tmp/github.txt\", \"github.com\")\n&gt;&gt;&gt; os.path.isfile(\"tmp/github.txt\")\n::: True\n</code></pre> Source code in <code>toliman/build/https.py</code> <pre><code>def download_byte_from_https(path: str, url: object) -&gt; None:\n\"\"\"\n    Download a single byte of a file from the internet.\n\n    This will save the first byte of a file on the internet to `path`.\n    If `path` already points to a file a warning is printed and the \n    download is skipped.\n\n    Parameters\n    ----------\n    path: str\n        The location to save the file to.\n    url: str\n        The address of the information on the internet.\n\n    Examples\n    --------\n    &gt;&gt;&gt; import os\n    &gt;&gt;&gt; os.mkdir(\"tmp\")\n    &gt;&gt;&gt; with open(\"tmp/text.txt\", \"w\") as file:\n    &gt;&gt;&gt;     pass\n    &gt;&gt;&gt; download_byte_from_https(\"tmp/text.txt\", \"github.com\")\n    ::: \"`path` exists. Skipping download\"\n    &gt;&gt;&gt; download_byte_from_https(\"tmp/github.txt\", \"github.com\")\n    &gt;&gt;&gt; os.path.isfile(\"tmp/github.txt\")\n    ::: True\n    \"\"\"\n    if os.path.isfile(path):\n        warnings.warn(\"`path` exists. Skipping download.\")\n        return None\n\n    response: iter = get_https_stream(url).iter_content(BYTE)\n\n    with open(path, \"wb\") as file:\n        file.write(next(response))\n</code></pre>"},{"location":"toliman/build/https/#toliman.build.https.get_https_stream","title":"Https","text":""},{"location":"toliman/build/https/#toliman.build.https.download_file_from_https","title":"Https","text":""},{"location":"toliman/build/https/#toliman.build.https.download_byte_from_https","title":"Https","text":""},{"location":"toliman/build/mask/","title":"Mask","text":""},{"location":"toliman/build/mask/#overview","title":"Overview","text":"<p>We are storing a copy of the mask on an orphaned branch hosted by github. This file contains that code that can be used to download that copy and  install it into the correct path. </p>"},{"location":"toliman/build/mask/#api","title":"API","text":"<code>is_mask_installed</code> <p>Check if the mask is installed.</p> <p>Parameters:</p> Name Type Description Default <code>root</code> <code>str</code> <p>The directory to search for an installation in.</p> required <p>Returns:</p> Name Type Description <code>installed</code> <code>bool</code> <p>True is the mask is installed else false.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import os\n&gt;&gt;&gt; os.mkdir(\"tmp\")\n&gt;&gt;&gt; is_mask_installed(\"tmp\")\n::: False\n&gt;&gt;&gt; open(\"tmp/mask.npy\", \"w\").close()\n&gt;&gt;&gt; is_mask_installed(\"tmp\")\n::: True\n</code></pre> Source code in <code>toliman/build/mask.py</code> <pre><code>def is_mask_installed(root: str) -&gt; bool:\n\"\"\"\n    Check if the mask is installed.\n\n    Parameters\n    ----------\n    root: str\n        The directory to search for an installation in.\n\n    Returns\n    -------\n    installed: bool\n        True is the mask is installed else false.\n\n    Examples\n    --------\n    &gt;&gt;&gt; import os\n    &gt;&gt;&gt; os.mkdir(\"tmp\")\n    &gt;&gt;&gt; is_mask_installed(\"tmp\")\n    ::: False\n    &gt;&gt;&gt; open(\"tmp/mask.npy\", \"w\").close()\n    &gt;&gt;&gt; is_mask_installed(\"tmp\")\n    ::: True\n    \"\"\"\n    if not os.path.isdir(root):\n        return False\n\n    return os.path.isfile(paths.concat([root, MASK_FILE]))\n</code></pre> <code>install_mask</code> <p>Install phoenix from the web.</p> <p>Parameters:</p> Name Type Description Default <code>root</code> <code>str</code> <p>The directory to search for an installation in.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; import os\n&gt;&gt;&gt; install_mask(\".assets\")\n&gt;&gt;&gt; os.path.isfile(\".assets/mask.npy\")\n::: True\n</code></pre> Source code in <code>toliman/build/mask.py</code> <pre><code>def install_mask(root: str) -&gt; bool:\n\"\"\"\n    Install phoenix from the web.\n\n    Parameters\n    ----------\n    root: str\n        The directory to search for an installation in.\n\n    Examples\n    --------\n    &gt;&gt;&gt; import os\n    &gt;&gt;&gt; install_mask(\".assets\")\n    &gt;&gt;&gt; os.path.isfile(\".assets/mask.npy\")\n    ::: True\n    \"\"\"\n    paths.mkdir_and_parents(root)\n    path: str = paths.concat([root, MASK_FILE])\n    https.download_file_from_https(path, MASK_HOME)\n</code></pre>"},{"location":"toliman/build/mask/#toliman.build.mask.is_mask_installed","title":"Mask","text":""},{"location":"toliman/build/mask/#toliman.build.mask.install_mask","title":"Mask","text":""},{"location":"toliman/build/paths/","title":"Paths","text":""},{"location":"toliman/build/paths/#overview","title":"Overview","text":"<p>This file likely does not need to exist. It was created before I discovered <code>os.makedirs</code> so it can be used to essentially achieve the same functionality. However, correcting this mistake would require a time investment and it simply isn't worth it since the code is not performance critical. <code>concat</code> on the  other hand is to make sure that the DRY principle is obeyed in the code.</p>"},{"location":"toliman/build/paths/#api","title":"API","text":"<code>accumulate</code> <p>Incrementally build a path from a list.</p> <p>Parameters:</p> Name Type Description Default <code>strings</code> <code>list</code> <p>A list of directories that can be pasted together to form a  list.</p> required <code>paths</code> <p>A list of the paths to each dir.</p> required <p>Returns:</p> Name Type Description <code>paths</code> <code>list</code> <p>Starting with the root directory, which is assumed to be the  first entry in <code>strings</code>, a list of directories growing from root.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; _accumulate_path([\"root\", \"dev\", \"null\"])\n::: [\"root\", \"root/dev\", \"root/dev/null\"]\n</code></pre> Source code in <code>toliman/build/paths.py</code> <pre><code>def accumulate(strings: list) -&gt; list:\n\"\"\"\n    Incrementally build a path from a list.\n\n    Parameters\n    ----------\n    strings: list \n        A list of directories that can be pasted together to form a \n        list.\n    paths: list\n        A list of the paths to each dir.\n\n    Returns\n    -------\n    paths: list\n        Starting with the root directory, which is assumed to be the \n        first entry in `strings`, a list of directories growing from\n        root.\n\n    Examples\n    --------\n    &gt;&gt;&gt; _accumulate_path([\"root\", \"dev\", \"null\"])\n    ::: [\"root\", \"root/dev\", \"root/dev/null\"]\n    \"\"\"\n    def accumulate(strings: list, paths: list) -&gt; list:\n        if not strings:\n            return paths\n        else:\n            if not paths:\n                paths.append(strings.pop(0))\n            else:\n                paths.append(concat([paths[-1], strings.pop(0)]))\n            return accumulate(strings, paths)\n\n    paths: list = []\n    return accumulate(strings, paths)\n</code></pre> <code>concat</code> <p>Fuse paths together.</p> <p>Parameters:</p> Name Type Description Default <code>paths</code> <code>list</code> <p>A list of paths/files to concatenate.</p> required <p>Returns:</p> Name Type Description <code>path</code> <code>str</code> <p>A path made from the other paths.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; concat([\"root\", \"dev\", \"null\"])\n::: \"root/dev/null\"`\n</code></pre> Source code in <code>toliman/build/paths.py</code> <pre><code>def concat(paths: list) -&gt; str:\n\"\"\"\n    Fuse paths together.\n\n    Parameters\n    ----------\n    paths: list\n        A list of paths/files to concatenate.\n\n    Returns\n    -------\n    path: str\n        A path made from the other paths.\n\n    Examples\n    --------\n    &gt;&gt;&gt; concat([\"root\", \"dev\", \"null\"])\n    ::: \"root/dev/null\"`\n    \"\"\"\n    return \"/\".join(paths)\n</code></pre>"},{"location":"toliman/build/paths/#toliman.build.paths.accumulate","title":"Paths","text":""},{"location":"toliman/build/paths/#toliman.build.paths.concat","title":"Paths","text":""},{"location":"toliman/build/phoenix/","title":"Phoenix","text":""},{"location":"toliman/build/phoenix/#overview","title":"Overview","text":"<p>Now, you are probably wondering what \"phoenix\" is? It is a shorthand name  for a set of stellar spectral models generated by <code>pysynphot</code>/<code>synphot</code>.  Most of the required datafiles are required for this model, even though  we studiously avoid downloading all but the essential files. When setting  the forwards model up, you will notice that <code>pysynphot</code> reports a lot of  missing files. That is because we only install the files that are required  for the phoenix model and no others.</p> <p>We have designed the code to save the spectra in a <code>.csv</code> of your choosing, since it is something that it unlikely (for the mean time) to be learned.  This may change with the addition of the sidelobes. However, if you wish to  simply generate the <code>.csv</code> and then delete the datafiles required by  <code>pysynphot</code> you will save some space and loose none of the forwards models  functionality. </p>"},{"location":"toliman/build/phoenix/#api","title":"API","text":"<code>is_phoenix_installed</code> <p>Check if \"phoenix\" is installed.</p> <p>Returns:</p> Name Type Description <code>installed</code> <code>bool</code> <p>True if all the phoenix files are present else false.</p> Source code in <code>toliman/build/phoenix.py</code> <pre><code>def is_phoenix_installed(root: str) -&gt; bool:\n\"\"\"\n    Check if \"phoenix\" is installed.\n\n    Returns\n    -------\n    installed: bool\n        True if all the phoenix files are present else false.\n    \"\"\"\n    home: str = paths.concat([root, HOME])\n    if not os.path.exists(home):\n        return False\n\n    for path in PATHS:\n        file: str = paths.concat([home, path])\n        if not os.path.isfile(file):\n            return False\n\n    return True\n</code></pre> <code>install_phoenix</code> <p>Install phoenix from the web.</p> <p>Parameters:</p> Name Type Description Default <code>root</code> <code>str</code> <p>The directory to use for the install.</p> required <code>full</code> <code>bool</code> <p>True if the entire file is to be downloaded.  False if only the first byte is to be downloaded. False is used for testing purposes only.</p> <code>False</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import os\n&gt;&gt;&gt; os.mkdir(\"tmp\")\n&gt;&gt;&gt; install_phoenix(\"tmp\", full = True)\n&gt;&gt;&gt; is_phoenix_installed(\"tmp\")\n::: True\n</code></pre> Source code in <code>toliman/build/phoenix.py</code> <pre><code>def install_phoenix(root: str, /, full: bool = False) -&gt; bool:\n\"\"\"\n    Install phoenix from the web.\n\n    Parameters\n    ----------\n    root: str\n        The directory to use for the install.\n    full: bool\n        True if the entire file is to be downloaded. \n        False if only the first byte is to be downloaded.\n        False is used for testing purposes only.\n\n    Examples\n    --------\n    &gt;&gt;&gt; import os\n    &gt;&gt;&gt; os.mkdir(\"tmp\")\n    &gt;&gt;&gt; install_phoenix(\"tmp\", full = True)\n    &gt;&gt;&gt; is_phoenix_installed(\"tmp\")\n    ::: True\n    \"\"\"\n    make_phoenix_dirs(root)\n\n    if not full:\n        warnings.warn(\"full = False\")\n\n    for file in PATHS:\n        path: str = paths.concat([root, HOME, file])\n        url: str = paths.concat([URL, file])\n\n        print(\"Downloading: {}.\".format(url))\n\n        if os.path.isfile(path):\n            warnings.warn(\"{} already exists.\".format(path))\n        else:\n            if full:\n                https.download_file_from_https(path, url)\n            else: \n                https.download_byte_from_https(path, url)\n</code></pre> <code>make_phoenix_dirs</code> <p>Build the directory structure demanded by <code>pysynphot</code>.</p> <p>The directory structure that <code>pysynphot</code> needs is <pre><code>root/\n    grid/\n        phoenix/\n            phoenixm00/\n            phoenixp03/\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>root</code> <code>str</code> <p>The directory in which to build.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; import os\n&gt;&gt;&gt; os.mkdir(\"tmp\")\n&gt;&gt;&gt; make_phoenix_dirs(\"tmp\")\n&gt;&gt;&gt; os.path.exists(\"tmp/grid\")\n::: True\n&gt;&gt;&gt; os.path.exists(\"tmp/grid/phoenix\")\n::: True\n&gt;&gt;&gt; os.path.exists(\"tmp/grid/phoenix/phoenixm00\")\n::: True\n&gt;&gt;&gt; os.path.exists(\"tmp/grid/phoenix/phoenixp03\")\n::: True\n</code></pre> Source code in <code>toliman/build/phoenix.py</code> <pre><code>def make_phoenix_dirs(root: str) -&gt; None:\n\"\"\"\n    Build the directory structure demanded by `pysynphot`.\n\n    The directory structure that `pysynphot` needs is\n    ```\n    root/\n        grid/\n            phoenix/\n                phoenixm00/\n                phoenixp03/\n    ```\n\n    Parameters\n    ----------\n    root: str\n        The directory in which to build.\n\n    Examples\n    --------\n    &gt;&gt;&gt; import os\n    &gt;&gt;&gt; os.mkdir(\"tmp\")\n    &gt;&gt;&gt; make_phoenix_dirs(\"tmp\")\n    &gt;&gt;&gt; os.path.exists(\"tmp/grid\")\n    ::: True\n    &gt;&gt;&gt; os.path.exists(\"tmp/grid/phoenix\")\n    ::: True\n    &gt;&gt;&gt; os.path.exists(\"tmp/grid/phoenix/phoenixm00\")\n    ::: True\n    &gt;&gt;&gt; os.path.exists(\"tmp/grid/phoenix/phoenixp03\")\n    ::: True\n    \"\"\"\n    home: str = paths.concat([root, HOME])\n    paths.mkdir_and_parents(home)\n\n    for pnx in [M00, P03]:\n        path: str = paths.concat([home, pnx])\n        if not os.path.exists(path):\n            os.mkdir(path)\n</code></pre> <code>make_phoenix_spectra</code> <p>Generate the spectra using phoenix.</p> <p>The spectrum is returned in an array so that the leading axis can be indexed via the following convention. WAVES: int = 0 ALPHA_CEN_A: int = 1 ALPHA_CEN_B: int = 2</p> <p>Parameters:</p> Name Type Description Default <code>root</code> <code>str</code> <p>The directory to look for the phoenix files in.</p> required Source code in <code>toliman/build/phoenix.py</code> <pre><code>def make_phoenix_spectra(root: str) -&gt; float:\n\"\"\"\n    Generate the spectra using phoenix.\n\n    The spectrum is returned in an array so that the leading axis\n    can be indexed via the following convention.\n    WAVES: int = 0\n    ALPHA_CEN_A: int = 1\n    ALPHA_CEN_B: int = 2\n\n    Parameters\n    ----------\n    root: str\n        The directory to look for the phoenix files in.\n    \"\"\"\n    if not is_phoenix_installed(root):\n        raise ValueError\n\n    set_phoenix_environ(root)\n\n    import pysynphot\n\n    alpha_cen_a_spectrum: float = pysynphot.Icat(\n        \"phoenix\",\n        ALPHA_CEN_A_SURFACE_TEMP,\n        ALPHA_CEN_A_METALICITY,\n        ALPHA_CEN_A_SURFACE_GRAV,\n    )\n\n    alpha_cen_b_spectrum: float = pysynphot.Icat(\n        \"phoenix\",\n        ALPHA_CEN_B_SURFACE_TEMP,\n        ALPHA_CEN_B_METALICITY,\n        ALPHA_CEN_B_SURFACE_GRAV,\n    )\n\n    spectra: float = np.array([\n            math.angstrom_to_m(alpha_cen_a_spectrum.wave),\n            math.normalise(alpha_cen_a_spectrum.flux),\n            math.normalise(alpha_cen_b_spectrum.flux),\n        ], dtype=float)\n\n    return spectra\n</code></pre> <code>save_phoenix_spectra</code> <p>Simulate the spectrum of the alpha centauri binary using <code>pysynphot</code>.</p> <p>The output is saved to a file so that it can be used again later without having to be reloaded.</p> <p>Parameters:</p> Name Type Description Default <code>root</code> <code>str</code> <p>The directory to save the file in.</p> required <code>spectra</code> <code>str</code> <p>An array representation of the spectra. This should be 3 by the  number of wavelengths.</p> required Source code in <code>toliman/build/phoenix.py</code> <pre><code>def save_phoenix_spectra(root: str, spectra: str) -&gt; None:\n\"\"\"\n    Simulate the spectrum of the alpha centauri binary using `pysynphot`.\n\n    The output is saved to a file so that\n    it can be used again later without having to be reloaded.\n\n    Parameters\n    ----------\n    root: str\n        The directory to save the file in.\n    spectra: float\n        An array representation of the spectra. This should be 3 by the \n        number of wavelengths.\n    \"\"\"\n    file: str = paths.concat([root, \"spectra.csv\"])\n\n    if not os.path.isdir(root): os.mkdir(root)\n    with open(file, \"w\") as fspectra:\n        fspectra.write(\"alpha cen a waves (m), \")\n        fspectra.write(\"alpha cen a flux (W/m/m), \")\n        fspectra.write(\"alpha cen b flux (W/m/m)\\n\")\n\n        for i in np.arange(spectra.shape[1], dtype=int):\n            fspectra.write(\"{}, \".format(spectra[WAVES][i]))\n            fspectra.write(\"{}, \".format(spectra[ALPHA_CEN_A][i]))\n            fspectra.write(\"{}\\n\".format(spectra[ALPHA_CEN_B][i]))\n</code></pre> <code>clip_phoenix_spectra</code> <p>Select the spectra within the filter.</p> <p>Parameters:</p> Name Type Description Default <code>spectra</code> <code>float</code> <p>The spectra representing alpha centrauri across the entire  electromagnetic spectrum.</p> required <p>Returns:</p> Name Type Description <code>spectra</code> <code>float</code> <p>The spectra within the filter.</p> Source code in <code>toliman/build/phoenix.py</code> <pre><code>def clip_phoenix_spectra(spectra: float) -&gt; float:\n\"\"\"\n    Select the spectra within the filter.\n\n    Parameters\n    ----------\n    spectra: float\n        The spectra representing alpha centrauri across the entire \n        electromagnetic spectrum.\n\n    Returns\n    -------\n    spectra: float\n        The spectra within the filter. \n    \"\"\"\n    decision: bool = np.logical_and(\n        (FILTER_MIN_WAVELENGTH &lt; spectra[WAVES]),\n        (spectra[WAVES] &lt; FILTER_MAX_WAVELENGTH)\n    )\n\n    return spectra[:, decision]\n</code></pre> <code>resample_phoenix_spectra</code> <p>Downsample the spectra.</p> <p>Reduce the sampling of the spectra to a number that can fit within  the device memory. The downsampling is done by taking averages.</p> <p>Parameters:</p> Name Type Description Default <code>spectra</code> <code>float</code> <p>The full resolution spectra.</p> required <code>number_of_wavelengths</code> <code>int</code> <p>The number of wavelengths to downsample to.</p> required <p>Returns:</p> Name Type Description <code>spectra</code> <code>float</code> <p>The spectra sampled by the number of wavelengths.</p> Source code in <code>toliman/build/phoenix.py</code> <pre><code>def resample_phoenix_spectra(spectra: float, number_of_wavelengths: int) -&gt; float:\n\"\"\"\n    Downsample the spectra.\n\n    Reduce the sampling of the spectra to a number that can fit within \n    the device memory. The downsampling is done by taking averages.\n\n    Parameters\n    ----------\n    spectra: float\n        The full resolution spectra.\n    number_of_wavelengths: int\n        The number of wavelengths to downsample to.\n\n    Returns\n    -------\n    spectra: float\n        The spectra sampled by the number of wavelengths.\n    \"\"\"\n    size: int = spectra[WAVES].size\n    resample_size: int = size - size % number_of_wavelengths\n    spectra: float = spectra[:, :resample_size]\n    resample_by: int = resample_size // number_of_wavelengths \n    return math.downsample_along_axis(spectra, resample_by, axis=1)\n</code></pre> <code>is_spectra_installed</code> <p>Check if the spectra are installed.</p> <p>Parameters:</p> Name Type Description Default <code>root</code> <code>str</code> <p>The directory to search for an installation in.</p> required <p>Returns:</p> Name Type Description <code>installed</code> <code>bool</code> <p>True is the spectra are installed else false.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import os\n&gt;&gt;&gt; os.mkdir(\"tmp\")\n&gt;&gt;&gt; is_spectra_installed(\"tmp\")\n::: False\n&gt;&gt;&gt; open(\"tmp/spectra.csv\", \"w\").close()\n&gt;&gt;&gt; is_spectra_installed(\"tmp\")\n::: True\n</code></pre> Source code in <code>toliman/build/phoenix.py</code> <pre><code>def is_spectra_installed(root: str) -&gt; bool:\n\"\"\"\n    Check if the spectra are installed.\n\n    Parameters\n    ----------\n    root: str\n        The directory to search for an installation in.\n\n    Returns\n    -------\n    installed: bool\n        True is the spectra are installed else false.\n\n    Examples\n    --------\n    &gt;&gt;&gt; import os\n    &gt;&gt;&gt; os.mkdir(\"tmp\")\n    &gt;&gt;&gt; is_spectra_installed(\"tmp\")\n    ::: False\n    &gt;&gt;&gt; open(\"tmp/spectra.csv\", \"w\").close()\n    &gt;&gt;&gt; is_spectra_installed(\"tmp\")\n    ::: True\n    \"\"\"\n    if not os.path.isdir(root):\n        return False\n\n    return os.path.isfile(paths.concat([root, \"spectra.csv\"]))\n</code></pre> <code>install_spectra</code> <p>Make and save the alpha centauri spectrum at a given resolution.</p> <p>This function assumes that phoenix is already installed. If it is  not installed then use the <code>install_phoenix</code> command. This module  is not necessarily intended to be user facing so be aware that in  general root should be TOLIMAN_HOME, but that is enforced upstream.</p> <p>Parameters:</p> Name Type Description Default <code>root</code> <code>str</code> <p>The directory to install the spectrum.</p> required <code>number_of_wavelengths</code> <code>int</code> <p>The resolution of the spectrum. &lt; 25 is not recommended but this is not enforced.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; import os\n&gt;&gt;&gt; import shutil\n&gt;&gt;&gt; if os.path.isdir(\"tmp\"):\n...     shutil.rmtree(\"tmp\")\n&gt;&gt;&gt; is_phoenix_installed(\"tmp\")\n::: False\n&gt;&gt;&gt; install_phoenix(\"tmp\")\n&gt;&gt;&gt; is_phoenix_installed(\"tmp\")\n::: True\n&gt;&gt;&gt; install_spectra(\"tmp\")\n&gt;&gt;&gt; is_spectra_installed(\"tmp\")\n::: True\n</code></pre> Source code in <code>toliman/build/phoenix.py</code> <pre><code>def install_spectra(root: str, number_of_wavelengths: int) -&gt; None:\n\"\"\"\n    Make and save the alpha centauri spectrum at a given resolution.\n\n    This function assumes that phoenix is already installed. If it is \n    not installed then use the `install_phoenix` command. This module \n    is not necessarily intended to be user facing so be aware that in \n    general root should be TOLIMAN_HOME, but that is enforced upstream.\n\n    Parameters\n    ----------\n    root: str\n        The directory to install the spectrum.\n    number_of_wavelengths: int\n        The resolution of the spectrum. &lt; 25 is not recommended but this\n        is not enforced.\n\n    Examples\n    --------\n    &gt;&gt;&gt; import os\n    &gt;&gt;&gt; import shutil\n    &gt;&gt;&gt; if os.path.isdir(\"tmp\"):\n    ...     shutil.rmtree(\"tmp\")\n    &gt;&gt;&gt; is_phoenix_installed(\"tmp\")\n    ::: False\n    &gt;&gt;&gt; install_phoenix(\"tmp\")\n    &gt;&gt;&gt; is_phoenix_installed(\"tmp\")\n    ::: True\n    &gt;&gt;&gt; install_spectra(\"tmp\")\n    &gt;&gt;&gt; is_spectra_installed(\"tmp\")\n    ::: True\n    \"\"\"\n    if not is_phoenix_installed(root):\n        raise ValueError(\"Phoenix not installed!\")\n\n    spectra: float = resample_phoenix_spectra(\n        clip_phoenix_spectra(make_phoenix_spectra(root)), \n        number_of_wavelengths\n    )\n\n    save_phoenix_spectra(root, spectra)\n</code></pre>"},{"location":"toliman/build/phoenix/#toliman.build.phoenix.is_phoenix_installed","title":"Phoenix","text":""},{"location":"toliman/build/phoenix/#toliman.build.phoenix.install_phoenix","title":"Phoenix","text":""},{"location":"toliman/build/phoenix/#toliman.build.phoenix.make_phoenix_dirs","title":"Phoenix","text":""},{"location":"toliman/build/phoenix/#toliman.build.phoenix.make_phoenix_spectra","title":"Phoenix","text":""},{"location":"toliman/build/phoenix/#toliman.build.phoenix.save_phoenix_spectra","title":"Phoenix","text":""},{"location":"toliman/build/phoenix/#toliman.build.phoenix.clip_phoenix_spectra","title":"Phoenix","text":""},{"location":"toliman/build/phoenix/#toliman.build.phoenix.resample_phoenix_spectra","title":"Phoenix","text":""},{"location":"toliman/build/phoenix/#toliman.build.phoenix.is_spectra_installed","title":"Phoenix","text":""},{"location":"toliman/build/phoenix/#toliman.build.phoenix.install_spectra","title":"Phoenix","text":""}]}