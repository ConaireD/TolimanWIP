   "source": [    "import jax.numpy as np\n",    "import matplotlib.pyplot as plt\n",    "import jax\n",    "import equinox as eqx\n",    "import os\n",    "import optax\n",    "import dLux as dl\n",    "import jax\n",    "\n",    "from jax import grad\n",    "from tqdm.notebook import tqdm\n",    "from IPython.display import clear_output\n",    "\n",    "jax.default_backend()\n"   ]   "source": [    "# NOTE: THIS NOTEBOOK IS RUNNING 32-bit\n",    "This **greatly** increases computation time as GPUs prefer 32-bit, however this means flux **must** be limited to a maximum of 1e12 photons"   ]   "source": [    "#jax.config.update(\"jax_enable_x64\", True)\n",    "r2a = dl.utils.radians_to_arcseconds\n",    "a2r = dl.utils.arcseconds_to_radians"   ]   "source": [    "mask = np.load('TolimanMask_sidelobes.npy')"   ]   "source": [    "# Generate mask and basic modelling parmaters\n",    "\n",    "central_wav = (595+695)/2\n",    "wavels = 1e-9 * np.linspace(595, 695, 10) # Wavelengths\n",    "aperture_diameter = 0.12\n",    "arcsec_per_pixel = 0.375\n",    "pixel_scale_out = dl.utils.arcseconds_to_radians(arcsec_per_pixel)\n",    "det_npix = 100# 2048\n",    "wf_npix = 1024\n",    "\n",    "\n",    "position = np.array([0.0,0.0])\n",    "flux = 1\n",    "separation = dl.utils.arcseconds_to_radians(8.0)\n",    "position_angle = np.pi/2\n",    "wavelengths = wavels\n"   ]   "source": [    "# Zernike Paramaters\n",    "basis = dl.utils.zernike_basis(10, wf_npix, outside=0.)[3:] #tip/tilt/piston not here (already simulated)\n",    "coeffs = 2e-8*jax.random.normal(jax.random.PRNGKey(0), [len(basis)])\n",    "\n",    "zernike_layer = dl.ApplyBasisOPD(basis, coeffs)\n",    "osys = dl.utils.toliman(mask.shape[0], det_npix, detector_pixel_size=r2a(pixel_scale_out), extra_layers=[dl.AddOPD(mask), zernike_layer])"   ]   "source": [    "def make_image(params, osys):\n",    "    zernikes = 'ApplyBasisOPD.coefficients'\n",    "    position = [a2r(params[0]), a2r(params[1])]\n",    "    separation = a2r(params[2])\n",    "    position_angle = params[3]\n",    "    zernike_params = 2e-8*params[4:]\n",    "    osys = osys.set(zernikes, zernike_params)\n",    "\n",    "    \n",    "    source = dl.BinarySource(position , flux, separation, position_angle, wavelengths = wavelengths)\n",    "    image = osys.model(source=source)\n",    "    image /= np.sum(image)\n",    "    return image\n",    "\n",    "@eqx.filter_jit\n",    "def compute_loss(params, osys, input_image):\n",    "    zernikes = 'ApplyBasisOPD.coefficients'\n",    "    image_params = params[:4]\n",    "    zernike_params = 2e-8*params[4:]\n",    "    osys = osys.set(zernikes, zernike_params)\n",    "    \n",    "    fmodel_image = make_image(params, osys)\n",    "    noise = np.sqrt(input_image)  # does this actually do anything?\n",    "    residual = (input_image - fmodel_image)/noise\n",    "    \n",    "    chi2 = np.sum(residual**2)\n",    "    return chi2\n",    "\n",    "def apply_photon_noise(image, seed = 0):\n",    "    key = jax.random.PRNGKey(seed)\n",    "    image_noisy = jax.random.poisson(key = key,lam = image)\n",    "    return image_noisy\n",    "\n",    "def apply_photon_noise(image, seed = 0):\n",    "    key = jax.random.PRNGKey(seed)\n",    "    image_noisy = jax.random.poisson(key = key,lam = image)\n",    "    image_noisy /= 1e5  # needed so next line doesn't cause underflow (?) errors for high fluxes\n",    "    image_noisy /= np.sum(image_noisy)\n",    "    return image_noisy"   ]   "source": [    "num_images = 100\n",    "\n",    "key = jax.random.PRNGKey(0)\n",    "position_vec = 0.05*jax.random.normal(key, (num_images,2))\n",    "separation_vec = 8 + 0.1*jax.random.normal(key, (1, num_images))\n",    "angle_vec = np.pi/2 + 0.02*jax.random.normal(key, (1,num_images))\n",    "\n",    "zern_coeff_mat = jax.random.normal(key, (len(basis), num_images)) #scale is applied later\n",    "\n",    "plt.figure()\n",    "plt.scatter(position_vec[:,0], position_vec[:,1], alpha = 0.5)\n",    "plt.title('position')\n",    " \n",    "plt.figure()\n",    "plt.hist(separation_vec[0,:], bins = 15)\n",    "plt.title('separation')\n",    "\n",    "plt.figure()\n",    "plt.hist(angle_vec[0,:], bins = 15)\n",    "plt.title('angle')"   ]   "source": [    "%%time\n",    "start_learning_rate = 4.5e-2\n",    "max_iter = 200\n",    "\n",    "opt = optax.rmsprop(learning_rate=start_learning_rate)\n",    "flux = 1e12\n",    "gtol = 5e-5\n",    "\n",    "estimated_pos_x = np.zeros(num_images)\n",    "estimated_pos_y = np.zeros(num_images)\n",    "estimated_sep   = np.zeros(num_images)\n",    "estimated_ang   = np.zeros(num_images)\n",    "\n",    "zernikes = 'ApplyBasisOPD.coefficients'\n",    "\n",    "plt.ion()\n",    "for i in range(num_images):\n",    "    # Define true/target params\n",    "    true_image_params = np.array([position_vec[i,0], position_vec[i,1], separation_vec[0,i], angle_vec[0,i]])\n",    "    true_zernike_params = zern_coeff_mat[:,i]\n",    "    true_params = np.concatenate((true_image_params, true_zernike_params))\n",    "    \n",    "    osys = osys.set(zernikes, true_zernike_params)\n",    "    # Create target image\n",    "    target_image = apply_photon_noise(make_image(true_params, osys)*flux)\n",    "    \n",    "    # Default starting params\n",    "    params = 1.1*true_params\n",    "    opt = optax.inject_hyperparams(optax.adam)(learning_rate=start_learning_rate)\n",    "    opt_state = opt.init(params)\n",    "    #model_osys = osys.set(zernikes, coeffs_init*1.05)\n",    "    \n",    "    # Do gradient descent\n",    "    lr = start_learning_rate\n",    "    for j in tqdm(range(max_iter)):\n",    "        grads = jax.grad(compute_loss)(params, osys, target_image)\n",    "        \n",    "        overall_gtol = np.sum(np.abs(grads))\n",    "        \n",    "        if overall_gtol < gtol:\n",    "            clear_output(wait=True)\n",    "            print('Gtol satisfied')\n",    "            break\n",    "        opt_state.hyperparams['learning_rate'] = lr\n",    "        updates, opt_state = opt.update(grads, opt_state)\n",    "        params = optax.apply_updates(params, updates)\n",    "        #model_osys = optax.apply_updates(model_osys, updates)\n",    "        #print(params/true_params)\n",    "        if j == max_iter - 1:\n",    "            clear_output(wait=True)\n",    "            print('Maximum iterations hit')\n",    "        \n",    "    estimated_params = params\n",    "    \n",    "    estimated_pos_x = estimated_pos_x.at[i].set(estimated_params[0])\n",    "    estimated_pos_y = estimated_pos_y.at[i].set(estimated_params[1])\n",    "    estimated_sep   = estimated_sep.at[i].set(estimated_params[2])\n",    "    estimated_ang   = estimated_ang.at[i].set(estimated_params[3])\n",    "    \n",    "    # Make plots\n",    "    \n",    "    print('Iteration: {}/{}'.format(i+1,num_images))\n",    "    plt.figure(figsize = (10,8))\n",    "    plt.subplot(2,2,1)\n",    "    plt.plot(np.abs(estimated_pos_x - position_vec[:,0])[:i+1], 'x')\n",    "    plt.hlines(np.mean(np.abs(estimated_pos_x - position_vec[:,0])[:i+1]), 0, i+1, ls = '--', color = 'black')\n",    "    plt.title('absolute x pos error')\n",    "    plt.yscale('log')\n",    "\n",    "    plt.subplot(2,2,2)\n",    "    plt.plot(np.abs(estimated_pos_y - position_vec[:,1])[:i+1], 'x')\n",    "    plt.hlines(np.mean(np.abs(estimated_pos_y - position_vec[:,1])[:i+1]), 0, i+1, ls = '--', color = 'black')\n",    "    plt.title('absolute y pos error')\n",    "    plt.yscale('log')\n",    "\n",    "    plt.subplot(2,2,3)\n",    "    plt.plot(np.abs(estimated_sep - separation_vec)[0,:i+1], 'x')\n",    "    plt.hlines(np.mean(np.abs(estimated_sep - separation_vec)[0,:i+1]), 0, i+1, ls = '--', color = 'black')\n",    "    plt.title('absolute seperation error')\n",    "    plt.yscale('log')\n",    "\n",    "    plt.subplot(2,2,4)\n",    "    plt.plot(np.abs(estimated_ang - angle_vec)[0,:i+1], 'x')\n",    "    plt.hlines(np.mean(np.abs(estimated_ang - angle_vec)[0,:i+1]), 0, i+1, ls = '--', color = 'black')\n",    "    plt.title('absolute angle error')\n",    "    plt.yscale('log')\n",    "    plt.show()"   ]   "source": [    "print(np.std(np.abs(estimated_sep - separation_vec)))\n",    "\n",    "# time for 32 8m53s for 100\n",    "# time for 64 31m39s for 30\n",    "\n",    "# note following table 32 bit had 100 iters, 64 had 30"   ]   "source": [    "| Offset | STD x32   | STD x64   | STDx32 with zerns |\n",    "|--------|-----------|-----------|-------------------|\n",    "| 1%     | 3.676e-06 | 2.424e-06 | 4.094e-06         |\n",    "| 5%     | 7.752e-06 | 5.765e-06 | 6.007e-06         |\n",    "| 10%    | 1.035e-05 |    n/a    | 7.397e-06         |\n",    "| 25%    | 0.0678    |    n/a    | 0.392             |"   ]
